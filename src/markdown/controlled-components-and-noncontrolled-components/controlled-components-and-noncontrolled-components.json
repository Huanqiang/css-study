{"content":"<h1 id=\"受控组件与非受控组件\">受控组件与非受控组件</h1>\n<p>在设计React 组件的时候，一定要注意数据来源，确保每一个数据都只有一个数据源。比如一个 <code>state</code> 不能既受 <code>setState</code> 的改变，又受 <code>props</code> 的变化而变化（比如<code>componentWillReceiveProps</code> 或是 <code>getDerivedStateFromProps</code> 中）。</p>\n<blockquote>\n<p>一旦遇到多数据来源的情况，请将其按照以下方案进行重新设计。</p>\n</blockquote>\n<blockquote>\n<p><code>getDerivedStateFromProps</code> 的作用：</p>\n<ol>\n<li><code>state</code> 只受到 <code>props</code> 的影响；</li>\n<li>只有当 <code>state</code> 与 <code>prop</code> 不同时，才去修改 <code>state</code>；</li>\n</ol>\n</blockquote>\n<h2 id=\"受控组件\">受控组件</h2>\n<p>受控组件是指 state 完全受Prop控制的组件。通常，建议将组件设计成完全受控组件。</p>\n<pre><code class=\"hljs react\">const <span class=\"hljs-type\">ControlComponent</span> = (props) =&gt; {\n    reutrn (&lt;div&gt;{ props.name }&lt;/div&gt;)\n}\n\n<span class=\"hljs-comment\">//  或者</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ControlComponent</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n    state = {\n    name: <span class=\"hljs-symbol\">'xx</span>x'\n  }\n\n    <span class=\"hljs-comment\">// 使用了 getDerivedStateFromProps 类更新的state，最好不要在组件中再使用</span>\n    <span class=\"hljs-comment\">// setState 来修改了，要保证数据来源的唯一性。</span>\n    staric getDerivedStateFromProps(nextProps, preState) {\n    <span class=\"hljs-keyword\">return</span> {name: nextProps.name}\n  }\n}</code></pre>\n<blockquote>\n<p>这个组件就是一个完全受控组件，它没有自身的状态，完全随着props改变而改变。</p>\n</blockquote>\n<h2 id=\"非受控组件\">非受控组件</h2>\n<p>非受控组价是指组件存在 state，且state仅保存在这个组件内部，受组件内部的 <code>setState</code> 改变，不受 <code>props</code> 影响。</p>\n<pre><code class=\"hljs react\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NoncontrolComponent</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n    state = {\n    name: <span class=\"hljs-symbol\">'insid</span>e'\n  }\n\n    change = () =&gt; {\n    <span class=\"hljs-keyword\">this</span>.setState({name: <span class=\"hljs-symbol\">'newNam</span>e'})\n  }\n\n    render() {\n    const { name } = <span class=\"hljs-keyword\">this</span>.state\n    <span class=\"hljs-keyword\">return</span> (&lt;button onClick={<span class=\"hljs-keyword\">this</span>.change}&gt;{name}&lt;/button&gt;)\n  }\n}</code></pre>\n<h2 id=\"带-key-的组件\">带 key 的组件</h2>\n<p>我们知道<code>key</code>是用来标识一个组件的。<code>React</code> 会根据 <code>key</code> 判断数组中的哪些元素改变了，哪些元素被新增删除了。如果数组中某个key消失了，React会认为这个元素被删除了，从而进行响应的操作。</p>\n<p>所以根据这个特性，我们可以给一个<strong>非受控组件</strong>设置一个动态的 <code>key</code>。当需要重置（？应该是重新构建）这个非受控组件的时候，我们可以直接改变 <code>key</code> 值就好了。</p>\n<blockquote>\n<p>这个key可以是有意义的，也可以是随机生成的。</p>\n</blockquote>\n<h2 id=\"用-prop-的-id-重置非受控组件\">用 prop 的 id 重置非受控组件</h2>\n<p>如果不给非受控组件设置key，但仍想重置/改变组件，我们可以通过在组件中设置一个额外的标识符来达到相同的目的。</p>\n<pre><code class=\"hljs react\">class NoncontrolComponent extends React.Component {\n  <span class=\"hljs-keyword\">state</span> = {\n    name: this.props.name,\n    id: this.props.id\n  }\n\n    static getDerivedStateFromProps(props, <span class=\"hljs-keyword\">state</span>) {\n    if (props.id !== <span class=\"hljs-keyword\">state</span>) {\n      return {\n        name: props.name,\n        id: props.id\n            }\n        }\n    return null // return null 表示不对 <span class=\"hljs-keyword\">state</span> 做改变\n  }\n}</code></pre>\n<h2 id=\"使用实例方法重置非受控组件\">使用实例方法重置非受控组件</h2>\n<p>此外，我们还可以在组件中创建一个重置<code>state</code>的的方法，然后让父组件通过 <code>ref</code> 来调用该方法以达到改变组件状态的目的。</p>\n<pre><code class=\"hljs react\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NoncontrolComponent</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n    state = {\n    name： <span class=\"hljs-symbol\">'xx</span>x'\n  }\n\n    reset = name =&gt; {\n        <span class=\"hljs-keyword\">this</span>.setState({ name }) \n  }\n  ....\n}\n<span class=\"hljs-comment\">// 父组件使用 this.refs.component.reset() 就可以改变组件状态了</span></code></pre>\n<blockquote>\n<p>参考：<a href=\"https://zh-hans.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#what-about-memoization\">你可能不需要使用派生 state</a></p>\n</blockquote>\n"}