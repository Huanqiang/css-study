{"content":"<h1 id=\"性能优化\">性能优化</h1>\n<h2 id=\"指标\">指标</h2>\n<p>先来看看所有可以用来衡量页面性能的指标</p>\n<h3 id=\"1-fp、fcp、lcp、tti\">1. FP、FCP、LCP、TTI</h3>\n<p><strong>FP（<code>First Paint</code>，首次绘制）</strong>：代表屏幕首次渲染像素的时间。比如 body、div 的背景色；</p>\n<p><strong>FCP（<code>First Contentful Paint</code>，首次内容绘制）</strong>：代表屏幕首席绘制内容（文字，背景图、非白色 canvans、svg）的时间；</p>\n<blockquote>\n<p>这里举个例子：</p>\n<ul>\n<li>当 body 没有背景色，div 中也没有内容时，<strong>不会</strong>触发任何绘制</li>\n<li>当 body 有背景色，div 没有内容时，<strong>只会</strong>触发 FP</li>\n<li>当 div 有内容时，不管 body 是否有颜色，<strong>都会</strong>触发 FP、FCP</li>\n</ul>\n<p>FP 和 FCP 可能是相同的时间，也可能是先 FP 后 FCP。</p>\n</blockquote>\n<p><strong>LCP（<code>Largest Contentful Paint</code>）</strong> 表示可视区“内容”最大的可见元素开始出现在屏幕上的时间点。最大可见元素指：img、video、svg 中的 img、url() 加载的 img 、包含 text node 的块级元素或者 inline text 的子元素；</p>\n<p><strong>TTI（<code>Time to Interactive</code>，“可交互时间”）</strong> 表示网页第一次 <strong>完全达到可交互状态</strong> 的时间点。可交互状态指的是页面上的 UI 组件是可以交互的（可以响应按钮的点击或在文本框输入文字等），不仅如此，此时主线程已经达到“流畅”的程度，主线程的任务均不超过 50 毫秒。TTI 很重要，因为 TTI 可以让我们了解我们的产品需要多久可以真正达到“可用”的状态；</p>\n<p>应用程序可能由于以下几个原因而无法响应用户输入：</p>\n<ul>\n<li>使页面上的组件正常工作所需的 JavaScript 尚未加载。</li>\n<li>有很长的任务阻塞主线程（如上一节所述）。</li>\n</ul>\n<p><img src=\"https://markoskon.com/static/abfea44d7a0539d58a69c8f2774870f7/6e6b4/perf-metrics-load-timeline.png\" alt=\"Performance metrics during page load\"></p>\n<blockquote>\n<p>引用自 <a href=\"https://markoskon.com/performance/#1-first-paint-fp\">Performance notes</a></p>\n</blockquote>\n<p>对于 FP 和 FCP，可以用以下代码来进行跟踪分析</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n  <span class=\"hljs-comment\">&lt;!-- Register the PerformanceObserver to track paint timing. --&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">const</span> observer = <span class=\"hljs-keyword\">new</span> PerformanceObserver(<span class=\"hljs-function\"><span class=\"hljs-params\">list</span> =&gt;</span> {\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> entry <span class=\"hljs-keyword\">of</span> list.getEntries()) {\n        <span class=\"hljs-comment\">// `name` will be either 'first-paint' or 'first-contentful-paint'.</span>\n        <span class=\"hljs-keyword\">const</span> { entryType, name, startTime, duration } = entry\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'类型'</span>, entryType)\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'具体指标'</span>, name)\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'开始时间'</span>, startTime)\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'duration'</span>, duration)\n      }\n    })\n    observer.observe({ <span class=\"hljs-attr\">entryTypes</span>: [<span class=\"hljs-string\">'paint'</span>] })\n  </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span></code></pre>\n<h3 id=\"speed-index\">Speed Index</h3>\n<p><code>Speed Index</code> 是指可视页面加载的视觉进度，计算内容绘制速度的总分。为此，首先需要能够计算在页面加载期间，各个时间点“完成”了多少部分。</p>\n<p>Lighthouse 使用<a href=\"https://github.com/paulirish/speedline\">Speedline Node.js 模块</a>生成 Speed Index 得分。</p>\n<blockquote>\n<p><a href=\"https://web.dev/speed-index/#what-speed-index-measures\">https://web.dev/speed-index/#what-speed-index-measures</a></p>\n</blockquote>\n<p>以下几个方式可以提高的 Speed Index 得分</p>\n<ul>\n<li><a href=\"https://web.dev/mainthread-work-breakdown\">最小化主线程工作</a></li>\n<li><a href=\"https://web.dev/bootup-time\">减少 JavaScript 执行时间</a></li>\n<li><a href=\"https://web.dev/font-display\">确保文本在 Webfont 加载期间保持可见</a></li>\n</ul>\n<h3 id=\"total-blocking-time\">Total Blocking Time</h3>\n<p>衡量从 FCP 到 TTI 之间主线程被阻塞时长的总和。</p>\n<p>主线程执行的任务分为长任务和短任务。规定持续时间超过 50ms 的任务为长任务，低于 50ms 的任务为短任务。长任务中超过 50ms 的时间被认为是“阻塞”的，因此，TBT 是所有长任务中阻塞时间的总和。</p>\n<h3 id=\"cumulative-layout-shift\">Cumulative Layout Shift</h3>\n<p>Cumulative Layout Shift (累计布局偏移) 有助于量化页面元素意外移动造成的用户视觉上的影响，能有效提高用户的观感体验。</p>\n<blockquote>\n<p><a href=\"https://web.dev/cls/\">https://web.dev/cls/</a></p>\n</blockquote>\n<h2 id=\"lighthouse\">Lighthouse</h2>\n<p>Lighthouse 是一种开源的自动化工具，用于提高网页质量。你可以在任何网页上运行它。它能够针对性能、可访问性、渐进式 Web 应用等进行审核。它识别和修复影响你网站性能、可访问性和用户体验的常见问题。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Huanqiang/imgBed/img/20210428152318.jpeg\" alt=\"Lighthouse 参数\"></p>\n<blockquote>\n<p>指标计算器：<a href=\"https://googlechrome.github.io/lighthouse/scorecalc/#FCP=567&amp;SI=988&amp;LCP=1239&amp;TTI=2498&amp;TBT=127&amp;CLS=0.03&amp;FCI=2228&amp;FMP=829&amp;device=desktop&amp;version=7.0.0\">https://googlechrome.github.io/lighthouse/scorecalc/#FCP=567&amp;SI=988&amp;LCP=1239&amp;TTI=2498&amp;TBT=127&amp;CLS=0.03&amp;FCI=2228&amp;FMP=829&amp;device=desktop&amp;version=7.0.0</a></p>\n</blockquote>\n<p>在 Lighthouse 中，我们可以看到整个网页的整体评分和各个指标的评分，以及影响得分地方，以便修改。</p>\n<h2 id=\"performance\">Performance</h2>\n<h3 id=\"network\">network</h3>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Huanqiang/imgBed/img/20210427143540.png\" alt=\"performance network\"></p>\n<p>一个请求的完整路径：</p>\n<p><code>Send Request</code> -&gt; <code>Request Start</code> -&gt; <code>Receive Response</code> -&gt; <code>Receive Data</code> -&gt; <code>Finish Loading</code></p>\n<ol>\n<li><code>Send Request</code>: 表示准备给这个外链对应的服务器发送请求；</li>\n<li><code>Request Start</code>: 表示开始发送请求；</li>\n<li><code>Receive Response</code>: 表示接收响应，这里是表示告诉浏览器可以开始从网络接收数据了；</li>\n<li><code>Receive Data</code>: 表示开始接收数据；</li>\n<li><code>Finish Loading</code>: 表示已经完成下载数据；</li>\n</ol>\n<p>我们结合 Network 的来看：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Huanqiang/imgBed/img/20210427104141\" alt=\"network timing\"></p>\n<ol>\n<li><code>Send Request</code> -&gt; <code>Request Start</code>: 相当于 <code>stalled</code> + <code>DNSL Lookup</code> + <code>inital connection</code> + <code>SSL</code></li>\n<li><code>Request Start</code> -&gt; <code>Receive Response</code>: 相当于 <code>request sent</code> + <code>waiting(TTFB)</code></li>\n<li><code>Receive Response</code> -&gt; <code>Receive Data</code>: 相当于 <code>Content Dwonload</code></li>\n<li><code>Receive Data</code> -&gt; <code>Finish Loading</code>：在上图就没有了，应该是解析文件的过程</li>\n</ol>\n<h3 id=\"main\">Main</h3>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Huanqiang/imgBed/img/20210427153417.png\" alt=\"页面加载事件\"></p>\n<h2 id=\"性能优化方式\">性能优化方式</h2>\n<blockquote>\n<p>在 《高性能网站建设指南》一书中，已经将性能优化的准则进行了描述，可以直接参考。</p>\n</blockquote>\n<p>在性能优化时，我们可以参照上面的性能指标来制定合理的优化方案。</p>\n<h3 id=\"加快-fp、fcp-和-tti\">加快 FP、FCP 和 TTI</h3>\n<p>使用缓存</p>\n<ol>\n<li>页面缓存</li>\n<li>图片缓存</li>\n<li>第三方 js 缓存</li>\n<li>http 缓存</li>\n</ol>\n<p>精简 JS</p>\n<p>移除无效脚本</p>\n<blockquote>\n<p>去除 core.js 打包</p>\n</blockquote>\n<p>延后非首屏渲染使用的 JS，比如使用 <code>async</code>、<code>defer</code> 、或放在 <code>html</code> 底部</p>\n<p><code>serviceworker</code> <code>precache</code> 阶段增加 cdn 名单</p>\n<p><code>css link</code> 使用 <code>dns-prefetch</code></p>\n<h3 id=\"优化-cumulative-layout-shift\">优化 Cumulative Layout Shift</h3>\n<p>影响 CLS 因素</p>\n<ul>\n<li>为图片、广告位、<code>iframes</code> 等设置尺寸</li>\n<li>不要动态注入渲染内容</li>\n<li>网页字体导致 FOIT/TOUT</li>\n<li><strong>动画优化</strong>：坚持使用 <code>transform</code> 和 <code>opacity</code> 属性更改来实现动画，CSS<a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/transform\"><code>transform</code></a>属性使您可以为元素设置动画，而不会触发布局转换。<ul>\n<li>不用更改<code>height</code>和<code>width</code>属性，请使用<code>transform: scale()</code>。</li>\n<li>左右移动的元件，避免改变<code>top</code>，<code>right</code>，<code>bottom</code>，或<code>left</code>属性，并使用<code>transform: translate()</code>来代替。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>参考：</p>\n<p><a href=\"https://web.dev/optimize-cls/\">Optimize Cumulative Layout Shift</a> &gt; <a href=\"https://developers.google.com/web/fundamentals/performance/rendering/stick-to-compositor-only-properties-and-manage-layer-count\">Stick to Compositor-Only Properties and Manage Layer Count</a></p>\n</blockquote>\n<h3 id=\"优化-lcp\">优化 LCP</h3>\n<ul>\n<li><p>服务器响应时间慢</p>\n<ul>\n<li><p>优化服务器；</p>\n</li>\n<li><p>使用 CDN，缩短用户访问 HTML 页面的时间；</p>\n</li>\n<li><p>缓存静态 HTML，使用 nginx 或云服务的缓存；</p>\n</li>\n<li><p>使用 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API\">service worker</a> 拦截请求，仅当内容更新的时候更新被缓存的页面内容；</p>\n</li>\n<li><p>使用 <code>rel=&quot;preconnect&quot;</code> 和 <code>rel=&quot;dns-prefetch&quot;</code> 来加速第三方服务的加载</p>\n<pre><code class=\"hljs html\">&lt;link <span class=\"hljs-attribute\">rel</span>=<span class=\"hljs-string\">\"preconnect\"</span> <span class=\"hljs-attribute\">href</span>=<span class=\"hljs-string\">\"https://example.com\"</span> /&gt;</code></pre>\n</li>\n</ul>\n</li>\n<li><p>优化 CSS 的加载和执行</p>\n<ul>\n<li><p><code>Minify</code> 化 css 的文件内容，加快网络请求的速度；</p>\n</li>\n<li><p>将非首屏渲染需要的 css 提取出来，延后加载；</p>\n<ul>\n<li>可以使用 <code>Chrome DevTools</code> 中的 <a href=\"https://developers.google.com/web/tools/chrome-devtools/coverage\"><code>Coverage</code></a> 功能来查找所有未使用的 CSS。</li>\n</ul>\n</li>\n<li><p>对于初始呈现不需要的任何 CSS，请使用 <a href=\"https://github.com/filamentgroup/loadCSS/blob/master/README.md\"><code>loadCSS</code></a> 来异步加载文件，这可以利用<code>rel=&quot;preload&quot;</code>和<code>onload</code>；</p>\n<pre><code class=\"hljs html\">&lt;link <span class=\"hljs-attribute\">rel</span>=<span class=\"hljs-string\">\"preload\"</span> <span class=\"hljs-attribute\">href</span>=<span class=\"hljs-string\">\"stylesheet.css\"</span> <span class=\"hljs-attribute\">as</span>=<span class=\"hljs-string\">\"style\"</span> <span class=\"hljs-attribute\">onload</span>=<span class=\"hljs-string\">\"this.rel='stylesheet'\"</span> /&gt;</code></pre>\n</li>\n<li><p>将最重要的 css 直接内联在 html 中，减少网络请求；</p>\n<ul>\n<li><a href=\"https://github.com/addyosmani/critical\">Critical</a>，<a href=\"https://github.com/filamentgroup/criticalCSS\">CriticalCSS</a>和<a href=\"https://github.com/pocketjoso/penthouse\">Penthouse</a>都是提取和内嵌 CSS 的软件包</li>\n<li><a href=\"https://github.com/GoogleChromeLabs/critters\">Critters</a>是一个 <code>webpack</code> 插件，可以内嵌关键 CSS 并延迟加载其余的</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>优化 <code>JavaScript</code> 的加载和执行</p>\n<ul>\n<li><code>Minify</code> 化 <code>css</code> 的文件内容</li>\n<li>将 JS 放在 <code>body</code> 底部引入；</li>\n<li>将第三方与首屏渲染无关的 js 使用 <code>async</code> 标签；</li>\n</ul>\n</li>\n<li><p>优化静态资源加载时间</p>\n<ul>\n<li>优化和压缩图像<ul>\n<li>使用 <code>webp</code> 格式</li>\n<li>使用 <code>cdn</code></li>\n</ul>\n</li>\n<li>预载重要资源<ul>\n<li>使用 <code>&lt;link rel=&quot;preload&quot;&gt;</code> 来预加载关键资源；</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>参考： <a href=\"https://web.dev/optimize-lcp/\">Optimize Largest Contentful Paint</a></p>\n</blockquote>\n<h2 id=\"参考\">参考</h2>\n<ul>\n<li><a href=\"https://juejin.cn/post/6844904200044806157#comment\">前端性能优化之性能指标</a></li>\n<li><a href=\"https://markoskon.com/performance/#1-first-paint-fp\">https://markoskon.com/performance/#1-first-paint-fp</a></li>\n<li><a href=\"https://juejin.cn/post/6904518037563506701#heading-4\">性能优化：什么是 CLS 以及如何优化它</a></li>\n<li><a href=\"https://yinode.tech/post/201901/%E4%BB%8Ejs%E7%9A%84%E9%98%BB%E5%A1%9E%E8%A7%92%E5%BA%A6%E8%B0%88%E8%B0%88%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/\">从 JS 的阻塞角度谈谈浏览器渲染原理</a></li>\n</ul>\n"}