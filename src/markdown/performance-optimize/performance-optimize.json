{"content":"<h1 id=\"性能优化\">性能优化</h1>\n<h2 id=\"指标\">指标</h2>\n<p>先来看看所有可以用来衡量页面性能的指标</p>\n<h3 id=\"1-fp、fcp、lcp、tti\">1. FP、FCP、LCP、TTI</h3>\n<p><strong>FP（<code>First Paint</code>，首次绘制）</strong>：代表屏幕首次渲染像素的时间。比如body、div的背景色；</p>\n<p><strong>FCP（<code>First Contentful Paint</code>，首次内容绘制）</strong>：代表屏幕首席绘制内容（文字，背景图、非白色 canvans、svg）的时间；</p>\n<blockquote>\n<p>这里举个例子：</p>\n<ul>\n<li>当 body 没有背景色，div 中也没有内容时，<strong>不会</strong>触发任何绘制</li>\n<li>当 body 有背景色，div 没有内容时，<strong>只会</strong>触发 FP</li>\n<li>当 div 有内容时，不管 body 是否有颜色，<strong>都会</strong>触发 FP、FCP</li>\n</ul>\n<p>FP和FCP可能是相同的时间，也可能是先FP后FCP。</p>\n</blockquote>\n<p><strong>LCP（<code>Largest Contentful Paint</code>）</strong> 表示可视区“内容”最大的可见元素开始出现在屏幕上的时间点。最大可见元素指：img、video、svg 中的 img、url() 加载的 img 、包含 text node 的块级元素或者 inline text 的子元素；</p>\n<p><strong>TTI（<code>Time to Interactive</code>，“可交互时间”）</strong> 表示网页第一次 <strong>完全达到可交互状态</strong> 的时间点。可交互状态指的是页面上的UI组件是可以交互的（可以响应按钮的点击或在文本框输入文字等），不仅如此，此时主线程已经达到“流畅”的程度，主线程的任务均不超过50毫秒。TTI很重要，因为TTI可以让我们了解我们的产品需要多久可以真正达到“可用”的状态；</p>\n<p>应用程序可能由于以下几个原因而无法响应用户输入：</p>\n<ul>\n<li>使页面上的组件正常工作所需的JavaScript尚未加载。</li>\n<li>有很长的任务阻塞主线程（如上一节所述）。</li>\n</ul>\n<p><img src=\"https://markoskon.com/static/abfea44d7a0539d58a69c8f2774870f7/6e6b4/perf-metrics-load-timeline.png\" alt=\"Performance metrics during page load\"></p>\n<blockquote>\n<p>引用自 <a href=\"https://markoskon.com/performance/#1-first-paint-fp\">Performance notes</a> </p>\n</blockquote>\n<p>对于FP和FCP，可以用以下代码来进行跟踪分析</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n  <span class=\"hljs-comment\">&lt;!-- Register the PerformanceObserver to track paint timing. --&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n  <span class=\"hljs-keyword\">const</span> observer = <span class=\"hljs-keyword\">new</span> PerformanceObserver(<span class=\"hljs-function\">(<span class=\"hljs-params\">list</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> entry <span class=\"hljs-keyword\">of</span> list.getEntries()) {\n      <span class=\"hljs-comment\">// `name` will be either 'first-paint' or 'first-contentful-paint'.</span>\n      <span class=\"hljs-keyword\">const</span> { entryType, name, startTime, duration } = entry\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'类型'</span>, entryType)\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'具体指标'</span>, name)\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'开始时间'</span>, startTime)\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'duration'</span>, duration)\n    }\n  });\n  observer.observe({<span class=\"hljs-attr\">entryTypes</span>: [<span class=\"hljs-string\">'paint'</span>]});\n  </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span></code></pre>\n<h3 id=\"speed-index\">Speed Index</h3>\n<p><code>Speed Index</code> 是指可视页面加载的视觉进度，计算内容绘制速度的总分。为此，首先需要能够计算在页面加载期间，各个时间点“完成”了多少部分。</p>\n<p> Lighthouse 使用<a href=\"https://github.com/paulirish/speedline\">Speedline Node.js模块</a>生成Speed Index得分。</p>\n<blockquote>\n<p><a href=\"https://web.dev/speed-index/#what-speed-index-measures\">https://web.dev/speed-index/#what-speed-index-measures</a></p>\n</blockquote>\n<p>以下几个方式可以提高的 Speed Index 得分</p>\n<ul>\n<li><a href=\"https://web.dev/mainthread-work-breakdown\">最小化主线程工作</a></li>\n<li><a href=\"https://web.dev/bootup-time\">减少JavaScript执行时间</a></li>\n<li><a href=\"https://web.dev/font-display\">确保文本在Webfont加载期间保持可见</a></li>\n</ul>\n<h3 id=\"total-blocking-time\">Total Blocking Time</h3>\n<p>衡量从FCP到TTI之间主线程被阻塞时长的总和。</p>\n<p>主线程执行的任务分为长任务和短任务。规定持续时间超过50ms的任务为长任务，低于50ms的任务为短任务。长任务中超过50ms的时间被认为是“阻塞”的，因此，TBT是所有长任务中阻塞时间的总和。</p>\n<h3 id=\"cumulative-layout-shift\">Cumulative Layout Shift</h3>\n<p>Cumulative Layout Shift  (累计布局偏移) 有助于量化页面元素意外移动造成的用户视觉上的影响，能有效提高用户的观感体验。</p>\n<blockquote>\n<p><a href=\"https://web.dev/cls/\">https://web.dev/cls/</a></p>\n</blockquote>\n<h2 id=\"lighthouse\">Lighthouse</h2>\n<p>Lighthouse 是一种开源的自动化工具，用于提高网页质量。你可以在任何网页上运行它。它能够针对性能、可访问性、渐进式 Web 应用等进行审核。它识别和修复影响你网站性能、可访问性和用户体验的常见问题。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Huanqiang/imgBed/img/20210428152318.jpeg\" alt=\"Lighthouse 参数\"></p>\n<blockquote>\n<p>指标计算器：<a href=\"https://googlechrome.github.io/lighthouse/scorecalc/#FCP=567&amp;SI=988&amp;LCP=1239&amp;TTI=2498&amp;TBT=127&amp;CLS=0.03&amp;FCI=2228&amp;FMP=829&amp;device=desktop&amp;version=7.0.0\">https://googlechrome.github.io/lighthouse/scorecalc/#FCP=567&amp;SI=988&amp;LCP=1239&amp;TTI=2498&amp;TBT=127&amp;CLS=0.03&amp;FCI=2228&amp;FMP=829&amp;device=desktop&amp;version=7.0.0</a></p>\n</blockquote>\n<p>在 Lighthouse 中，我们可以看到整个网页的整体评分和各个指标的评分，以及影响得分地方，以便修改。</p>\n<h2 id=\"performance\">Performance</h2>\n<h3 id=\"network\">network</h3>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Huanqiang/imgBed/img/20210427143540.png\" alt=\"performance network\"></p>\n<p>一个请求的完整路径：</p>\n<p><code>Send Request</code> -&gt; <code>Request Start</code> -&gt;  <code>Receive Response</code> -&gt;  <code>Receive Data</code>  -&gt; <code>Finish Loading</code></p>\n<ol>\n<li><code>Send Request</code>: 表示准备给这个外链对应的服务器发送请求；</li>\n<li><code>Request Start</code>: 表示开始发送请求；</li>\n<li><code>Receive Response</code>: 表示接收响应，这里是表示告诉浏览器可以开始从网络接收数据了；</li>\n<li><code>Receive Data</code>: 表示开始接收数据；</li>\n<li><code>Finish Loading</code>: 表示已经完成下载数据；</li>\n</ol>\n<p>我们结合 Network 的来看：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Huanqiang/imgBed/img/20210427104141\" alt=\"network timing\"></p>\n<p><code>Send Request</code> -&gt; <code>Request Start</code>: 相当于 <code>stalled</code> + <code>DNSL Lookup</code> + <code>inital connection</code> + <code>SSL</code></p>\n<p><code>Request Start</code> -&gt;  <code>Receive Response</code>: 相当于  <code>request sent</code> + <code>waiting(TTFB)</code></p>\n<p><code>Receive Response</code> -&gt;  <code>Receive Data</code>:  相当于 <code>Content Dwonload</code></p>\n<p><code>Receive Data</code>  -&gt; <code>Finish Loading</code>：在上图就没有了，应该是解析文件的过程</p>\n<h3 id=\"main\">Main</h3>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Huanqiang/imgBed/img/20210427153417.png\" alt=\"页面加载事件\"></p>\n<h2 id=\"性能优化方式\">性能优化方式</h2>\n<blockquote>\n<p>在 《高性能网站建设指南》一书中，已经将性能优化的准则进行了描述，可以直接参考。</p>\n</blockquote>\n<p>在性能优化时，我们可以参照上面的性能指标来制定合理的优化方案。</p>\n<h3 id=\"加快-fp、fcp-和-tti\">加快 FP、FCP 和 TTI</h3>\n<p>使用缓存</p>\n<ol>\n<li>页面缓存</li>\n<li>图片缓存</li>\n<li>第三方 js 缓存</li>\n<li>http 缓存</li>\n</ol>\n<p>精简JS</p>\n<p>移除无效脚本</p>\n<blockquote>\n<p>去除core.js打包</p>\n</blockquote>\n<p>延后非首屏渲染使用的JS，比如使用 async、defer 、或放在html底部</p>\n<p>serviceworker precache阶段增加cdn名单</p>\n<p>css link 使用 dns-prefetch</p>\n<h3 id=\"优化-cumulative-layout-shift\">优化 Cumulative Layout Shift</h3>\n<p>影响CLS因素</p>\n<ul>\n<li>为图片、广告位、iframes等设置尺寸</li>\n<li>不要动态注入渲染内容</li>\n<li>网页字体导致FOIT/TOUT</li>\n<li><strong>动画优化</strong>：坚持使用 transform 和 opacity 属性更改来实现动画，CSS<a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/transform\"><code>transform</code></a>属性使您可以为元素设置动画，而不会触发布局转换。<ul>\n<li>不用更改<code>height</code>和<code>width</code>属性，请使用<code>transform: scale()</code>。</li>\n<li>左右移动的元件，避免改变<code>top</code>，<code>right</code>，<code>bottom</code>，或<code>left</code>属性，并使用<code>transform: translate()</code>来代替。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>参考：</p>\n<p><a href=\"https://web.dev/optimize-cls/\">Optimize Cumulative Layout Shift</a></p>\n<p><a href=\"https://developers.google.com/web/fundamentals/performance/rendering/stick-to-compositor-only-properties-and-manage-layer-count\">Stick to Compositor-Only Properties and Manage Layer Count</a> </p>\n</blockquote>\n<h3 id=\"优化lcp\">优化LCP</h3>\n<ul>\n<li><p>服务器响应时间慢</p>\n<ul>\n<li><p>优化服务器；</p>\n</li>\n<li><p>使用CDN，缩短用户访问HTML页面的时间；</p>\n</li>\n<li><p>缓存静态HTML，使用nginx 或云服务的缓存；</p>\n</li>\n<li><p>使用 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API\">service worker</a> 拦截请求，仅当内容更新的时候更新被缓存的页面内容；</p>\n</li>\n<li><p>使用 <code>rel=&quot;preconnect&quot;</code> 和 <code>rel=&quot;dns-prefetch&quot;</code> 来加速第三方服务的加载</p>\n<pre><code class=\"hljs html\">&lt;link <span class=\"hljs-attribute\">rel</span>=<span class=\"hljs-string\">\"preconnect\"</span> <span class=\"hljs-attribute\">href</span>=<span class=\"hljs-string\">\"https://example.com\"</span> /&gt;</code></pre>\n</li>\n</ul>\n</li>\n<li><p>优化CSS 的加载和执行</p>\n<ul>\n<li><p>Minify 化css的文件内容，加快网络请求的速度；</p>\n</li>\n<li><p>将非首屏渲染需要的 css 提取出来，延后加载；</p>\n<ul>\n<li>可以使用Chrome DevTools中的 <a href=\"https://developers.google.com/web/tools/chrome-devtools/coverage\">Coverage</a> 功能来查找所有未使用的CSS。</li>\n</ul>\n</li>\n<li><p>对于初始呈现不需要的任何CSS，请使用<a href=\"https://github.com/filamentgroup/loadCSS/blob/master/README.md\">loadCSS</a>来异步加载文件，这可以利用<code>rel=&quot;preload&quot;</code>和<code>onload</code>；</p>\n<pre><code class=\"hljs html\">&lt;link <span class=\"hljs-attribute\">rel</span>=<span class=\"hljs-string\">\"preload\"</span> <span class=\"hljs-attribute\">href</span>=<span class=\"hljs-string\">\"stylesheet.css\"</span> <span class=\"hljs-attribute\">as</span>=<span class=\"hljs-string\">\"style\"</span> <span class=\"hljs-attribute\">onload</span>=<span class=\"hljs-string\">\"this.rel='stylesheet'\"</span>&gt;</code></pre>\n</li>\n<li><p>将最重要的 css 直接内联在html中，减少网络请求；</p>\n<ul>\n<li><a href=\"https://github.com/addyosmani/critical\">Critical</a>，<a href=\"https://github.com/filamentgroup/criticalCSS\">CriticalCSS</a>和<a href=\"https://github.com/pocketjoso/penthouse\">Penthouse</a>都是提取和内嵌CSS的软件包</li>\n<li><a href=\"https://github.com/GoogleChromeLabs/critters\">Critters</a>是一个webpack插件，可以内嵌关键CSS并延迟加载其余的</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>优化 JavaScript 的加载和执行</p>\n<ul>\n<li>Minify 化css的文件内容</li>\n<li>将 JS 放在body底部引入；</li>\n<li>将第三方与首屏渲染无关的js 使用 async 标签；</li>\n</ul>\n</li>\n<li><p>优化静态资源加载时间</p>\n<ul>\n<li>优化和压缩图像<ul>\n<li>使用webp格式</li>\n<li>使用cdn</li>\n</ul>\n</li>\n<li>预载重要资源<ul>\n<li>使用 <code>&lt;link rel=&quot;preload&quot;&gt;</code> 来预加载关键资源；</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>参考： <a href=\"https://web.dev/optimize-lcp/\">Optimize Largest Contentful Paint</a> </p>\n</blockquote>\n<h2 id=\"参考\">参考</h2>\n<ul>\n<li><a href=\"https://juejin.cn/post/6844904200044806157#comment\">前端性能优化之性能指标</a></li>\n<li><a href=\"https://markoskon.com/performance/#1-first-paint-fp\">https://markoskon.com/performance/#1-first-paint-fp</a></li>\n<li><a href=\"https://juejin.cn/post/6904518037563506701#heading-4\">性能优化：什么是CLS以及如何优化它</a> </li>\n<li><a href=\"https://yinode.tech/post/201901/%E4%BB%8Ejs%E7%9A%84%E9%98%BB%E5%A1%9E%E8%A7%92%E5%BA%A6%E8%B0%88%E8%B0%88%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/\">从JS的阻塞角度谈谈浏览器渲染原理</a></li>\n</ul>\n"}