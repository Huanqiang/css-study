{"content":"<h1 id=\"xss-和-csrf\"><code>XSS</code> 和 <code>CSRF</code></h1>\n<h2 id=\"xss\"><code>xss</code></h2>\n<p><code>xss</code>（<code>Cross-Site Scripting</code>， 跨站脚本），<code>xss</code> 就是在网站中插入一个恶意代码（比如网站的评论区等可以输入的地方），然后网站不知道你输入了什么东西，就将其保存到了数据库，当其他用户访问到的时候，浏览器就会自动执行这段恶意代码，从而注入恶作剧脚本或者获取其他用户的<code>cookie</code>等隐私数据。</p>\n<p>案例：</p>\n<ol>\n<li>点开一下网址：<a href=\"http://js.jirengu.com/lejo/1/%EF%BC%9B\">http://js.jirengu.com/lejo/1/；</a></li>\n<li>然后输入 <code>&lt;script&gt;alert(111)&lt;/script&gt;</code>（这里也可以换成一串链接什么的）；</li>\n<li>点击提交后，你的页面上马上会弹出一个 <code>alert</code>，显示 111；</li>\n</ol>\n<p>这是因为当你输入 <code>&lt;script&gt;alert(111)&lt;/script&gt;</code> 后，服务器没有处理这个字符串，直接将这段代码返回，而浏览器就会直接执行该代码，这就是典型的 <code>xss</code>。</p>\n<h3 id=\"恶意脚本\">恶意脚本</h3>\n<ol>\n<li><code>存储型XSS</code>：恶意代码是被存储在服务器中的，如在个人信息或发表文章等地方加入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，用户访问该页面的时候触发代码执行。这种 XSS 比较危险，容易造成蠕虫，盗窃 cookie 等。</li>\n<li><code>反射型XSS</code>：非持久化，需要欺骗用户自己去点击链接（<strong>恶意代码被附加到了 <code>url</code> 中</strong>）才能触发 <code>XSS</code> 代码（服务器中没有这样的页面和内容），一般容易出现在搜索页面。</li>\n<li><code>DOM型XSS</code>：通过操作 DOM 元素的 API（比如 <code>.innerHTML</code> 、<code>.outerHTML</code>、 <code>.appendChild</code>、 <code>document.write()</code> 等）来实现恶意代码的注入。<code>DOM型XSS</code> 可以是存储型的也可以是反射型的。</li>\n</ol>\n<p><code>DOM型XSS</code> 举例：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"link\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"text\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"\"</span> /&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"button\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"按钮\"</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"button\"</span> <span class=\"hljs-attr\">onclick</span>=<span class=\"hljs-string\">\"test()\"</span> /&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">test</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">let</span> text = <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'text'</span>).value\n    <span class=\"hljs-comment\">// 利用了 innerHTML 注入了一个跳转到 恶意网站的 a标签</span>\n    <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'link'</span>).innerHTML = <span class=\"hljs-string\">`&lt;a href=\"<span class=\"hljs-subst\">${text}</span>\"&gt;链接&lt;/a&gt;`</span>\n  }\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre>\n<h3 id=\"防范手段\">防范手段</h3>\n<ol>\n<li>对于企图获取用户 <code>cookie</code> 的，可以使用 <code>HttpOnly</code> 来防止劫取 <code>Cookie</code>；</li>\n<li>不要相信用户输入，对用户输入进行检查、过滤和转义。建立可信任的字符和 <code>HTML</code> 标签白名单，对于不在白名单之列的字符或者标签进行过滤或编码。</li>\n<li>将用户数据输出到 <code>html</code> 标签的属性时，必须经过标签属性的转义。注意：不包含<code>href</code>, <code>src</code>, <code>style</code>和事件处理函数属性（比如<code>onmouseover</code>）。</li>\n<li>对用户输入的<code>url</code>进行限制，比如知乎就是，点击用户提供的<code>url</code>都会有提示。</li>\n</ol>\n<h2 id=\"csrf\"><code>csrf</code></h2>\n<p><code>csrf</code> （<code>Cross-Site Request Forgery</code>，跨站请求伪造），是指用户被引诱打开了一个第三方网站，且在第三方网站中不慎发起了对原网站的带<code>cookie</code>的请求。</p>\n<h3 id=\"流程\">流程</h3>\n<p>大致流程如下：</p>\n<ol>\n<li>用户在 A 网站登录，保留了登录信息 <code>Cookie</code>；</li>\n<li>用户打开了 B 网站（这个 B 网站是一个黑客的恶意网页）；</li>\n<li>用户在 B 网站中无意触发了 A 网站的请求，</li>\n<li>因为用户之前就已经登录过 A 网站，所以该请求是能够被 A 网站认证的，A 网站处理请求；</li>\n</ol>\n<h3 id=\"如何在-b-网站发送-a-网站的请求\">如何在 B 网站发送 A 网站的请求</h3>\n<p><strong>1. 自动发起 <code>GET</code> 请求</strong></p>\n<p>利用 HTML 能自动发送请求的标签：比如 <code>img</code> 标签 和 <code>script</code> 标签</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"https://platforma.com/withdraw?account=hacker名&amp;money=1000\"</span> /&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"https://platforma.com/withdraw?account=hacker名&amp;money=1000\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre>\n<p>利用这类标签，用户一进入 B 网站后就会自动发送请求。</p>\n<blockquote>\n<p>原理：img 标签是不受同源策略的限制，可以跨域加载资源的。</p>\n</blockquote>\n<p><strong>2. 自动发起 <code>POST</code> 请求</strong></p>\n<p>这类其实就是表单的自动提交。以下是黑客网站上的代码，一旦跳转到黑客指定的页面就会自动提交表单：</p>\n<pre><code class=\"hljs html\">&lt;form action=\"https://platforma.com/withdraw\" <span class=\"hljs-keyword\">method</span>=\"POST\"&gt;\n  &lt;<span class=\"hljs-keyword\">input</span> <span class=\"hljs-keyword\">type</span>=\"hidden\" <span class=\"hljs-type\">name</span>=\"account\" <span class=\"hljs-keyword\">value</span>=\"hacker\" /&gt;\n  &lt;<span class=\"hljs-keyword\">input</span> <span class=\"hljs-keyword\">type</span>=\"hidden\" <span class=\"hljs-type\">name</span>=\"money\" <span class=\"hljs-keyword\">value</span>=\"1000\" /&gt;\n&lt;/form&gt;\n&lt;script&gt;\n  document.forms[<span class=\"hljs-number\">0</span>].submit()\n&lt;/script&gt;</code></pre>\n<p><strong>3. 点击链接来触发请求</strong></p>\n<p>这种伪造请求的方式和第一种很像，不过是将请求的接口放到了 <code>&lt;a&gt;</code> 链接上：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"美女图片的链接\"</span> /&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"https://platforma.com/withdraw?account=hacker名&amp;money=1000\"</span>&gt;</span>\n  点击查看更多美女图片\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span>\n/&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span></code></pre>\n<h3 id=\"防范手段-1\">防范手段</h3>\n<ol>\n<li><strong><code>token</code></strong>：除了 <code>cookie</code> 认证外，对于重要的请求，在 http header 中还应该使用 <code>token</code> 来判断请求的来源。</li>\n<li><strong>同源检测</strong>： 在服务端，通过请求头中携带的 <code>Origin</code> 或者 <code>Referer</code> 属性值进行判断请求是否来源同一站点，同时服务器应该优先检测 <code>Origin</code>。为了安全考虑，相比于 <code>Referer</code>，<code>Origin</code> 只包含了域名而不带路径。</li>\n<li><strong>给 Cookie 设置合适的 SameSite</strong>：当从 A 网站登录后，会从响应头中返回服务器设置的 <code>Cookie</code> 信息，而如果 <code>Cookie</code> 携带了 <code>SameSite=strict</code> 则表示完全禁用第三方站点请求头携带 <code>Cookie</code>，比如当从 B 网站请求 A 网站接口的时候，浏览器的请求头将不会携带该 <code>Cookie</code>。</li>\n</ol>\n<h2 id=\"参考\">参考</h2>\n<ol>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/22500730\">「每日一题」XSS 是什么？</a></p>\n</li>\n<li><p><a href=\"https://www.jianshu.com/p/64a413ada155\">XSS 和 CSRF 攻击详解</a></p>\n</li>\n<li><p><a href=\"https://github.com/dwqs/blog/issues/68#\">浅说 XSS 和 CSRF</a></p>\n</li>\n<li><p>推荐阅读：<a href=\"https://bubuzou.com/2020/12/04/web-security/\">浏览器专题之安全篇</a></p>\n</li>\n</ol>\n"}