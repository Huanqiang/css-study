{"content":"<h1 id=\"简易脚手架\">简易脚手架</h1>\n<p>我们在使用 <code>vue-cli</code>、<code>create-react-app</code> 的时候，只要执行一个简单的命令 <code>vue init app</code> 或是  <code>create-react-app app</code> 就是快速创建出一个可直接使用的项目模板，极大地提高了开发效率。</p>\n<p>本文提供了一个开发简易脚手架的过程。</p>\n<h2 id=\"准备工作\">准备工作</h2>\n<h3 id=\"第三方工具\">第三方工具</h3>\n<ul>\n<li><a href=\"https://github.com/tj/commander.js\">comander</a>： <code>tj</code> 大神出品的<code>nodejs</code>命令行解决方案，用于捕获控制台输入的命令；</li>\n<li><a href=\"https://github.com/chalk/chalk\">chalk</a>：命令行文字配色工具；</li>\n<li><a href=\"https://github.com/moxystudio/node-cross-spawn\">cross-spawn</a>：跨平台的 <code>node</code> spawn/spawnSync 解决方案；</li>\n<li><a href=\"https://github.com/jprichardson/node-fs-extra\">fs-extra</a>：<code>nodejs</code> <code>fs</code> 的加强版，新增了API的同时，也包含了原<code>fs</code>的<code>API</code>；</li>\n<li><a href=\"https://github.com/wycats/handlebars.js/\">handlebars</a>：一个字符串模板工具，可以将信息填充到模板的指定位置；</li>\n<li><a href=\"https://github.com/SBoudrias/Inquirer.js/\">inquirer</a>：交互式命令行用户界面集合，用于使用者补充信息或是选择操作；</li>\n<li><a href=\"https://github.com/sindresorhus/log-symbols\">log-symbols</a>：不同日志级别的彩色符号标志，包含了 <code>info</code>、<code>success</code>、<code>warning</code> 和 <code>error</code> 四级；</li>\n<li><a href=\"https://github.com/sindresorhus/ora\">ora</a>：动态加载操作符号；</li>\n</ul>\n<h3 id=\"初始化项目\">初始化项目</h3>\n<p>首先，这仍然是一个 <code>nodejs</code> 的工程项目，所以我们新建一个名为 <code>scaffold-demo</code> 的文件夹，并使用 <code>npm init</code> 来初始化项目。此时，项目中只有一个 <code>package.json</code> 文件，内容如下：</p>\n<pre><code class=\"hljs json\">{\n  <span class=\"hljs-attr\">\"name\"</span>: <span class=\"hljs-string\">\"scaffold-demo\"</span>,\n  <span class=\"hljs-attr\">\"version\"</span>: <span class=\"hljs-string\">\"1.0.0\"</span>,\n  <span class=\"hljs-attr\">\"description\"</span>: <span class=\"hljs-string\">\"\"</span>,\n  <span class=\"hljs-attr\">\"main\"</span>: <span class=\"hljs-string\">\"index.js\"</span>,\n  <span class=\"hljs-attr\">\"scripts\"</span>: {\n    <span class=\"hljs-attr\">\"test\"</span>: <span class=\"hljs-string\">\"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"</span>\n  },\n  <span class=\"hljs-attr\">\"author\"</span>: <span class=\"hljs-string\">\"\"</span>,\n  <span class=\"hljs-attr\">\"license\"</span>: <span class=\"hljs-string\">\"ISC\"</span>\n}</code></pre>\n<p>然后我们删除 <code>&quot;main&quot;: &quot;index.js&quot;</code>，加入 <code>&quot;private&quot;: false</code>。</p>\n<blockquote>\n<p><code>main</code>：是程序的主要入口点，就是说如果有其他用户 <code>install</code> 并 <code>requrie</code> 这个包，那么将返回该文件 <code>export</code> 出来的对象。</p>\n<p><code>private</code>：是为了保护私有库的手段，当你的库是私有库的时候，加入 <code>&quot;private&quot;: true</code>，那么<code>npm</code>将会拒绝发布这个库。</p>\n</blockquote>\n<p>我们在使用其他脚手架时，在控制台中输入一段简短的命令就能快速创建一个项目模板，那么他们是如何使用命令行来操作运行项目的呢，答案就在 <code>npm</code> 的 <code>package.json</code> 的 <code>bin</code> 字段值中。</p>\n<blockquote>\n<p><code>bin</code> 字段接受一个 k-v 的<code>Map</code>，其中 <code>key</code> 表示命令名称，<code>value</code>表示命令执行的入口文件。当设置了<code>bin</code>字段后，一旦安装了你的 <code>package</code>，<code>npm</code>将会这个命令注册到全局中，并链接对应的文件，然后用户就可以直接使用该命令了。</p>\n<p>详见：<a href=\"https://docs.npmjs.com/files/package.json#bin\">npm bin 官方文档</a></p>\n</blockquote>\n<p>我们需要在 <code>package.json</code> 文件中加入以下内容，其中这个 <code>sd</code> 就是我们命令：</p>\n<pre><code class=\"hljs json\"><span class=\"hljs-string\">\"bin\"</span>: {\n  <span class=\"hljs-string\">\"sd\"</span>: <span class=\"hljs-string\">\"./main.js\"</span>\n},</code></pre>\n<p>然后在项目中新建 <code>main.js</code> 文件，内容如下：</p>\n<pre><code class=\"hljs javascript\"><span class=\"hljs-meta\">#!/usr/bin/env node</span>\n\nconsole.<span class=\"hljs-built_in\">log</span>('Hello Bin')</code></pre>\n<blockquote>\n<p>其中 <code>#!/usr/bin/env node</code> 的作用就是这行代码是当系统运行到这一行的时候，去 <code>env</code> 中查找 <code>node</code> 配置，并且调用对应的解释器来运行之后的 <code>node</code> 程序。</p>\n</blockquote>\n<p>然后我们执行命令 <code>npm link</code> 或是 <code>npm install -g</code>，这样将本项目的命令注册到了全局中，然后在命令行中执行 <code>sd</code> 就能看到结果 <code>Hello Bin</code> 。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Huanqiang/imgBed/blog/first-npm.png\" alt=\"first-npm\"></p>\n<blockquote>\n<p><code>npm link</code> :将当前 <code>package</code> 链接到全局执行环境。</p>\n<p><code>npm install -g</code>：将当前 package 全局安装到本地。</p>\n<p>对应的解除命令为： <code>npm unlink</code> 或是 <code>npm uninstall -g</code></p>\n</blockquote>\n<h2 id=\"正式开始\">正式开始</h2>\n<p>现在我们已经能够完成最基础的命令行操作了，继续构建我们简易脚手架。</p>\n<h3 id=\"1-捕获命令信息\">1. 捕获命令信息</h3>\n<p>在上文，我们设置了bin信息，但是只有一个命令名称信息，但是在其他脚手架中，我们可以输入多个字段，如 <code>create-react-app app</code> 中 <code>create-reate-app</code> 表示命令，<code>app</code>表示创建的项目的名称。而这种捕获命令行的操作我们可以借助 <a href=\"https://github.com/tj/commander.js\">comander</a> 来完成。</p>\n<blockquote>\n<p>实际上，<code>vue</code> 和 <code>react</code> 的脚手架也是借助 <a href=\"https://github.com/tj/commander.js\">comander</a> 完成的。</p>\n</blockquote>\n<p>我们将 <code>main.js</code> 做如下修改：</p>\n<pre><code class=\"hljs js\">#<span class=\"hljs-comment\">!/usr/bin/env node</span>\nconst <span class=\"hljs-function\"><span class=\"hljs-keyword\">program</span></span> = require(<span class=\"hljs-string\">'commander'</span>)\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">program</span></span>\n  .command(<span class=\"hljs-string\">'init &lt;name&gt;'</span>)\n  .description(<span class=\"hljs-string\">'初始化模板'</span>)\n  .<span class=\"hljs-keyword\">action</span>(<span class=\"hljs-keyword\">name</span> =&gt; {\n    console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">'Hello '</span> + <span class=\"hljs-keyword\">name</span>)\n  })\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">program</span>.<span class=\"hljs-title\">parse</span><span class=\"hljs-params\">(process.argv)</span></span></code></pre>\n<p>然后在命令行输入 <code>sd init firstApp</code>，就能看到返回 <code>Hello firstApp</code>了。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Huanqiang/imgBed/blog/npm-firstApp.png\" alt=\"npm-firstApp\"></p>\n<p>在上述代码中，<code>command</code> 函数表示当前命令的一个子命令，可以设置多个，紧随的 <code>description</code> 用于描述该命令，<code>action</code> 表示输入命令后需要执行的操作。其中 <code>command</code> 中的尖括号（<code>&lt;&gt;</code>）表示该参数为必须输入的，中括号（<code>[]</code>）表示为可选的。 <code>program.parse(process.argv)</code> 必须要，如果没有则不会起作用。</p>\n<blockquote>\n<p>更详细例子参考官网的例子：<a href=\"https://github.com/tj/commander.js/#examples\">https://github.com/tj/commander.js/#examples</a></p>\n</blockquote>\n<h3 id=\"2-复制项目模板至指定目录\">2. 复制项目模板至指定目录</h3>\n<p>在本文中我们采用的本地项目模板复制的方式，即本脚手架中包含了所需要初始项目的模板文件，位于<code>Template</code>文件夹下（这个目录开发者可以随意修改）。</p>\n<blockquote>\n<p>如果想使用在线模板的方式，可以借助工具 <code>download-git-repo</code>，将 copy 换成下载即可。</p>\n<p>本文的 <code>template</code> 内容见文末的代码仓库。</p>\n</blockquote>\n<p>然后我们将 <code>action</code> 中的逻辑替换成如下内容：</p>\n<pre><code class=\"hljs javascript\">action(<span class=\"hljs-keyword\">async</span> name =&gt; {\n    <span class=\"hljs-comment\">// 判断用户是否输入应用名称，如果没有设置为 myApp</span>\n  <span class=\"hljs-keyword\">const</span> projectName = name || <span class=\"hljs-string\">'myApp'</span>\n  <span class=\"hljs-comment\">// 获取 template 文件夹路径</span>\n  <span class=\"hljs-keyword\">const</span> sourceProjectPath = __dirname + <span class=\"hljs-string\">'/template'</span>\n  <span class=\"hljs-comment\">// 获取命令所在文件夹路径</span>\n  <span class=\"hljs-comment\">// path.resolve(name) == process.cwd() + '/' + name</span>\n  <span class=\"hljs-keyword\">const</span> targetProjectPath = path.resolve(projectName)\n\n  <span class=\"hljs-comment\">// 创建一个空的文件夹</span>\n  fs.emptyDirSync(targetProjectPath)\n\n  <span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-comment\">// 将模板文件夹中的内容复制到目标文件夹（目标文件夹为命令输入所在文件夹）</span>\n    fs.copySync(sourceProjectPath, targetProjectPath)\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'已经成功拷贝 Template 文件夹下所有文件！'</span>)\n  } <span class=\"hljs-keyword\">catch</span> (err) {\n    <span class=\"hljs-built_in\">console</span>.error(<span class=\"hljs-string\">'项目初始化失败，已退出!'</span>)\n    <span class=\"hljs-keyword\">return</span>\n  }\n}</code></pre>\n<h3 id=\"3-确认目标文件夹是否存在（命令行交互）\">3. 确认目标文件夹是否存在（命令行交互）</h3>\n<p>我们已经完成了最基础简单的目标文件复制的过程，但是在实际过程中，很有可能存在用户输入的文件夹已经存在了的情况，所以我们需要询问用户是要覆盖原文件夹内容还是退出重新操作。这一块的操作我们使用 <a href=\"https://github.com/SBoudrias/Inquirer.js/\">inquirer</a> 来完成，<a href=\"https://github.com/SBoudrias/Inquirer.js/\">inquirer</a> 可以提供命令行的用户交互功能。</p>\n<p>我们在创建空文件夹之前加入一下判断文件是否存在的代码。</p>\n<pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 判断文件夹是否存在</span>\n<span class=\"hljs-keyword\">if</span> (fs.existsSync(targetProjectPath)) {\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`文件夹 <span class=\"hljs-subst\">${projectName}</span> 已经存在！`</span>)\n  <span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-comment\">// 若存在，则询问用户是否覆盖当前文件夹的内容，yes 则覆盖，no 则退出。</span>\n    <span class=\"hljs-keyword\">const</span> { isCover } = <span class=\"hljs-keyword\">await</span> inquirer.prompt([\n      { name: <span class=\"hljs-string\">'isCover'</span>, message: <span class=\"hljs-string\">'是否要覆盖当前文件夹的内容'</span>, <span class=\"hljs-keyword\">type</span>: <span class=\"hljs-string\">'confirm'</span> }\n    ])\n    <span class=\"hljs-keyword\">if</span> (!isCover) {\n      <span class=\"hljs-keyword\">return</span>\n    }\n  } <span class=\"hljs-keyword\">catch</span> (error) {\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'项目初始化失败，已退出!'</span>)\n    <span class=\"hljs-keyword\">return</span>\n  }\n}</code></pre>\n<blockquote>\n<p>请注意这里使用了 <code>async - await</code> 。</p>\n</blockquote>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Huanqiang/imgBed/blog/app-exist.png\" alt=\"app-exist\"></p>\n<h3 id=\"4-美化命令行-console\">4. 美化命令行 console</h3>\n<p>现在的命令行都是单调的白色字，我们使用 <a href=\"https://github.com/chalk/chalk\">chalk</a> 和 <a href=\"https://github.com/sindresorhus/log-symbols\">log-symbols</a> 来实现命令行的美化。主要代码如下：</p>\n<blockquote>\n<p>主要改了 <code>console</code> 部分的代码，使用  <a href=\"https://github.com/sindresorhus/log-symbols\">log-symbols</a> 添加输出标识， <a href=\"https://github.com/chalk/chalk\">chalk</a> 改变文字颜色。</p>\n</blockquote>\n<pre><code class=\"hljs javascript\">action(<span class=\"hljs-name\">async</span> name =&gt; {\n  // 判断用户是否输入应用名称，如果没有设置为 myApp\n  const projectName = name || 'myApp'\n  // 获取 template 文件夹路径\n  const sourceProjectPath = __dirname + '/template'\n  // 获取命令所在文件夹路径\n  // path.resolve(<span class=\"hljs-name\">name</span>) == process.cwd() + '/' + name\n  const targetProjectPath = path.resolve(<span class=\"hljs-name\">projectName</span>)\n\n  // 判断文件夹是否存在及其后续逻辑\n  if (<span class=\"hljs-name\">fs</span>.existsSync(<span class=\"hljs-name\">targetProjectPath</span>)) {\n    console.log(<span class=\"hljs-name\">symbols</span>.info, chalk.blue(`文件夹 ${projectName} 已经存在！`))\n    try {\n      const { isCover } = await inquirer.prompt([\n        { name: 'isCover', message: '是否要覆盖当前文件夹的内容', type: 'confirm' }\n      ])\n      if (!isCover) {\n        return\n      }\n    } catch (<span class=\"hljs-name\">error</span>) {\n      console.log(<span class=\"hljs-name\">symbols</span>.fail, chalk.red('项目初始化失败，已退出!'))\n\n      return\n    }\n  }\n  // 创建一个空的文件夹\n  fs.emptyDirSync(<span class=\"hljs-name\">targetProjectPath</span>)\n\n  try {\n    // 将模板文件夹中的内容复制到目标文件夹（目标文件夹为命令输入所在文件夹）\n    fs.copySync(<span class=\"hljs-name\">sourceProjectPath</span>, targetProjectPath)\n    console.log(<span class=\"hljs-name\">symbols</span>.success, chalk.green('已经成功拷贝 Template 文件夹下所有文件！'))\n  } catch (<span class=\"hljs-name\">err</span>) {\n    console.error(<span class=\"hljs-name\">symbols</span>.fail, chalk.red('项目初始化失败，已退出!'))\n    return\n  }\n})</code></pre>\n<p>美化前：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Huanqiang/imgBed/blog/console-normal.png\" alt=\"console-normal\"></p>\n<p>美化后：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Huanqiang/imgBed/blog/console-beautify.png\" alt=\"console-beautify\"></p>\n<h3 id=\"5-修改-packagejson\">5. 修改 package.json</h3>\n<p>有些时候，我们需要根据用户输入来修改填充 <code>package.json</code>，就像 <code>npm init</code> 的时候输入的信息。在这里我们使用 <a href=\"https://github.com/SBoudrias/Inquirer.js/\">inquirer</a> 获取用户输入，使用 <a href=\"https://github.com/wycats/handlebars.js/\">handlebars</a> 来将用户输入填充到  <code>package.json</code> 中去。</p>\n<p>在拷贝文件夹后加入以下代码：</p>\n<pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 获取项目的描述及作者名称等信息</span>\n<span class=\"hljs-keyword\">const</span> { projectDescription, projectAuthor } = <span class=\"hljs-keyword\">await</span> inquirer.prompt([\n  { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'projectDescription'</span>, <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">'请输入项目描述'</span> },\n  { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'projectAuthor'</span>, <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">'请输入作者名字'</span> }\n])\n\n<span class=\"hljs-keyword\">const</span> meta = {\n  projectAuthor,\n  projectDescription,\n  projectName\n}\n\n<span class=\"hljs-comment\">// 获取拷贝后的模板项目中的 `package.json`</span>\n<span class=\"hljs-keyword\">const</span> targetPackageFile = targetProjectPath + <span class=\"hljs-string\">'/package.json'</span>\n<span class=\"hljs-keyword\">if</span> (fs.pathExistsSync(targetPackageFile)) {\n  <span class=\"hljs-comment\">// 读取文件，并转换成字符串模板</span>\n  <span class=\"hljs-keyword\">const</span> content = fs.readFileSync(targetPackageFile).toString()\n  <span class=\"hljs-comment\">// 利用 handlebars 将需要的内容写入到模板中</span>\n  <span class=\"hljs-keyword\">const</span> result = handlebars.compile(content)(meta)\n  fs.writeFileSync(targetPackageFile, result)\n} <span class=\"hljs-keyword\">else</span> {\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'package.json 文件不存在：'</span> + targetPackageFile)\n}</code></pre>\n<p>至此，我们的简易脚手架已经基本搭建完成了，能够在指定文件夹生成项目模板文件。但是，我们如果使用 <code>create-react-app</code> 的话，就会发现只要你一执行命令就会它帮你自动安装依赖，而且也会自动初始化 <code>Git</code>。</p>\n<p>现在我们就来完成这两个功能。</p>\n<h3 id=\"6-安装依赖\">6. 安装依赖</h3>\n<pre><code class=\"hljs json\"><span class=\"hljs-comment\">// 通过执行命令 yarn --version 的方式，来判断本机是否已经安装了 yarn</span>\n<span class=\"hljs-comment\">// 如果安装了，后续就使用yarn，否则就使用 npm；</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">canUseYarn</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">try</span> {\n    spawn(<span class=\"hljs-string\">'yarnpkg'</span>, [<span class=\"hljs-string\">'--version'</span>])\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n  } <span class=\"hljs-keyword\">catch</span> (error) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n  }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">tryYarn</span>(<span class=\"hljs-params\">root</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">let</span> child\n    <span class=\"hljs-keyword\">const</span> isUseYarn = canUseYarn()\n    <span class=\"hljs-keyword\">if</span> (isUseYarn) {\n      <span class=\"hljs-comment\">// 这里就相当于命令行中执行 `yarn`</span>\n      child = spawn(<span class=\"hljs-string\">'yarnpkg'</span>, [<span class=\"hljs-string\">'--cwd'</span>, root], { <span class=\"hljs-attr\">stdio</span>: <span class=\"hljs-string\">'inherit'</span> })\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-comment\">// 这里就相当于命令行中执行 `npm install`</span>\n      child = spawn(<span class=\"hljs-string\">'npm'</span>, [<span class=\"hljs-string\">'install'</span>], { <span class=\"hljs-attr\">cwd</span>: root, <span class=\"hljs-attr\">stdio</span>: <span class=\"hljs-string\">'inherit'</span> })\n    }\n        <span class=\"hljs-comment\">// 当命令执行完成的时候，判断是否执行成功，并输出相应的输出。</span>\n    child.on(<span class=\"hljs-string\">'close'</span>, code =&gt; {\n      <span class=\"hljs-keyword\">if</span> (code !== <span class=\"hljs-number\">0</span>) {\n        reject(<span class=\"hljs-built_in\">console</span>.log(symbols.error, chalk.red(isUseYarn ? <span class=\"hljs-string\">'yarn'</span> : <span class=\"hljs-string\">'npm'</span> + <span class=\"hljs-string\">' 依赖安装失败...'</span>)))\n        <span class=\"hljs-keyword\">return</span>\n      }\n      resolve(<span class=\"hljs-built_in\">console</span>.log(symbols.success, chalk.green(isUseYarn ? <span class=\"hljs-string\">'yarn'</span> : <span class=\"hljs-string\">'npm'</span> + <span class=\"hljs-string\">' 依赖安装完成!'</span>)))\n    })\n  })\n}</code></pre>\n<blockquote>\n<p>这里需要注意的是执行命令语句 <code>spawn(&#39;yarnpkg&#39;, [&#39;--cwd&#39;, root], { stdio: &#39;inherit&#39; })</code>。</p>\n<p>上述语句相当于命令行中执行 <code>yarn</code>，但是我们必须加上 <code>&#39;--cwd&#39;</code> 来将其执行路径修改为命令所在的目录，因为 <code>spawn</code> 默认执行目录是脚手架目录。同时又因为 <code>spawn</code> 是开了一个子线程，所以如果你不使用 <code>{ stdio: &#39;inherit&#39; }</code>，那么你将看不到 <code>yarn</code> 安装的过程。</p>\n<blockquote>\n<p>参考博客：<a href=\"https://juejin.im/post/5b10a814f265da6e2a08a6f7\">Node.js child_process模块解读</a></p>\n<p><code>stdio</code> 选项用于配置父进程和子进程之间建立的管道，由于 <code>stdio</code> 管道有三个(<code>stdin</code>, <code>stdout</code>, <code>stderr</code>）因此 <code>stdio</code> 的三个可能的值其实是数组的一种简写</p>\n<ul>\n<li><code>pipe</code> 相当于 <code>[&#39;pipe&#39;, &#39;pipe&#39;, &#39;pipe&#39;]</code>（默认值）</li>\n<li><code>ignore</code> 相当于 <code>[&#39;ignore&#39;, &#39;ignore&#39;, &#39;ignore&#39;]</code></li>\n<li><code>inherit</code> 相当于 <code>[process.stdin, process.stdout, process.stderr]</code> </li>\n</ul>\n</blockquote>\n</blockquote>\n<p>然后在修改 <code>package.json</code> 代码后面添加以下代码即可。</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 安装依赖</span>\nawait <span class=\"hljs-keyword\">try</span><span class=\"hljs-constructor\">Yarn(<span class=\"hljs-params\">targetProjectPath</span>)</span></code></pre>\n<h3 id=\"7-初始化-git\">7. 初始化 Git</h3>\n<p>然后我们进行git的初始化，即执行 <code>git init</code>。</p>\n<pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> tryInitGit<span class=\"hljs-built_in\">(root</span>) {\n  // 原本模板中，我们就存放了 gitignore 模板文件，需要将其内容复制到新建的 .gitignore 文件中\n  <span class=\"hljs-keyword\">try</span> {\n    // 如果项目中存在了 .gitignore 文件，那么这个 API 会执行失败，跳入 <span class=\"hljs-keyword\">catch</span> 分支进行合并操作\n    fs.moveSync<span class=\"hljs-built_in\">(path</span>.join<span class=\"hljs-built_in\">(root</span>, <span class=\"hljs-string\">'gitignore'</span>),<span class=\"hljs-built_in\"> path</span>.join<span class=\"hljs-built_in\">(root</span>, <span class=\"hljs-string\">'.gitignore'</span>))\n  } <span class=\"hljs-keyword\">catch</span> <span class=\"hljs-built_in\">(error</span>) {\n    const content = fs.readFileSync<span class=\"hljs-built_in\">(path</span>.join<span class=\"hljs-built_in\">(root</span>, <span class=\"hljs-string\">'gitignore'</span>))\n    fs.appendFileSync<span class=\"hljs-built_in\">(path</span>.join<span class=\"hljs-built_in\">(root</span>, <span class=\"hljs-string\">'.gitignore'</span>), content)\n  } finally {\n    // 移除 gitignore 模板文件\n    fs.removeSync<span class=\"hljs-built_in\">(path</span>.join<span class=\"hljs-built_in\">(root</span>, <span class=\"hljs-string\">'gitignore'</span>))\n  }\n\n  <span class=\"hljs-keyword\">try</span> {\n    spawn(<span class=\"hljs-string\">'git'</span>, [<span class=\"hljs-string\">'init'</span>], { cwd:<span class=\"hljs-built_in\"> root</span> })\n    spawn(<span class=\"hljs-string\">'git'</span>, [<span class=\"hljs-string\">'add .'</span>], { cwd:<span class=\"hljs-built_in\"> root</span> })\n    spawn(<span class=\"hljs-string\">'git'</span>, [<span class=\"hljs-string\">'commit'</span>, <span class=\"hljs-string\">'-m'</span>, <span class=\"hljs-string\">'Initial commit from New App'</span>], { cwd:<span class=\"hljs-built_in\"> root</span> })\n    console.log(symbols.success, chalk.green(<span class=\"hljs-string\">'Git 初始化完成!'</span>))\n  } <span class=\"hljs-keyword\">catch</span> <span class=\"hljs-built_in\">(error</span>) {\n    console.log(symbols<span class=\"hljs-built_in\">.error</span>, chalk.red(<span class=\"hljs-string\">'Git 初始化失败...'</span>))\n  }\n}</code></pre>\n<p>然后在安装依赖之后加入以下代码：</p>\n<pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 初始化 git</span>\n<span class=\"hljs-keyword\">try</span><span class=\"hljs-constructor\">InitGit(<span class=\"hljs-params\">targetProjectPath</span>)</span></code></pre>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Huanqiang/imgBed/blog/completed.png\" alt=\"completed\"></p>\n<h2 id=\"总结\">总结</h2>\n<p>本文代码仓库：<a href=\"https://github.com/Huanqiang/scaffold-demo\">https://github.com/Huanqiang/scaffold-demo</a></p>\n<p>本文总结了个人在搭建简易脚手架的过程，功能过于简单，算是一个小小的开端吧。</p>\n<p>最后不由感叹 <code>nodejs</code> 还是非常之强悍的！</p>\n"}