{"content":"<h1 id=\"外观模式\">外观模式</h1>\n<h2 id=\"外观模式-1\">外观模式</h2>\n<p>外观模式又称为门面模式，是一种使用频率非常高的结构型设计模式，它通过引入一个外观角色来简化客户端与子系统之间的交互，为复杂的子系统调用提供一个统一的入口，降低子系统与客户端的耦合度，且客户端调用非常方便。</p>\n<p>外观模式包含如下两个角色：</p>\n<p><strong>Facade（外观角色）</strong>：在客户端可以调用它的方法，在外观角色中可以知道相关的（一个或者多个）子系统的功能和责任；在正常情况下，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理。</p>\n<p><strong>SubSystem（子系统角色）</strong>：在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能；每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求；子系统并不知道外观的存在，对于子系统而言，外观角色仅仅是另外一个客户端而已。</p>\n<p>外观模式的目的不是给予子系统添加新的功能接口，而是为了让外部减少与子系统内多个模块的交互，松散耦合，从而让外部能够更简单地使用子系统。</p>\n<p>外观模式的本质是：<strong>封装交互，简化调用</strong>。</p>\n<h3 id=\"举个例子\">举个例子</h3>\n<ul>\n<li>背景：小明的爷爷已经 80 岁了，一个人在家生活：每次都需要打开灯、打开电视、打开空调；睡觉时关闭灯、关闭电视、关闭空调；</li>\n<li>冲突：行动不方便，走过去关闭那么多电器很麻烦，所以需要为小明的爷爷提供一个便捷的操作：</li>\n</ul>\n<ol>\n<li>家具类</li>\n</ol>\n<pre><code class=\"hljs java\"><span class=\"hljs-comment\">//灯类</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SubSystemA_Light</span> {</span>\n     <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">on</span><span class=\"hljs-params\">()</span></span>{\n        System.out.<span class=\"hljs-built_in\">println</span>(<span class=\"hljs-string\">\"打开了灯....\"</span>);\n    }\n\n     <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">off</span><span class=\"hljs-params\">()</span></span>{\n        System.out.<span class=\"hljs-built_in\">println</span>(<span class=\"hljs-string\">\"关闭了灯....\"</span>);\n    }\n}\n\n<span class=\"hljs-comment\">//电视类</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SubSystemB_Television</span> {</span>\n     <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">on</span><span class=\"hljs-params\">()</span></span>{\n        System.out.<span class=\"hljs-built_in\">println</span>(<span class=\"hljs-string\">\"打开了电视....\"</span>);\n    }\n\n     <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">off</span><span class=\"hljs-params\">()</span></span>{\n        System.out.<span class=\"hljs-built_in\">println</span>(<span class=\"hljs-string\">\"关闭了电视....\"</span>);\n    }\n}\n\n<span class=\"hljs-comment\">//空调类</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SubSystemC_Aircondition</span> {</span>\n     <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">on</span><span class=\"hljs-params\">()</span></span>{\n        System.out.<span class=\"hljs-built_in\">println</span>(<span class=\"hljs-string\">\"打开了电视....\"</span>);\n    }\n\n     <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">off</span><span class=\"hljs-params\">()</span></span>{\n        System.out.<span class=\"hljs-built_in\">println</span>(<span class=\"hljs-string\">\"关闭了电视....\"</span>);\n    }\n}</code></pre>\n<ol start=\"2\">\n<li>外观类：集成遥控器，将各类电器同一作用（逻辑）的操作封装在一起，比如起床了，就封装 开灯、开电视和开空调这三个操作。</li>\n</ol>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Facade</span>{\n\n    SubSystemA_Light light；\n    SubSystemB_Television television ；\n    SubSystemC_Aircondition aircondition；\n\n\n    <span class=\"hljs-comment\">//传参</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Facade</span>(<span class=\"hljs-params\">SubSystemA_Light light,SubSystemB_Television television,SubSystemC_Aircondition aircondition</span>)</span>{\n        <span class=\"hljs-keyword\">this</span>.light = light;\n        <span class=\"hljs-keyword\">this</span>.television  = television ;\n        <span class=\"hljs-keyword\">this</span>.aircondition =aircondition;\n    }\n    <span class=\"hljs-comment\">//起床后一键开电器</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-keyword\">on</span>{\n        System.<span class=\"hljs-keyword\">out</span>.prinln(<span class=\"hljs-string\">\"起床了\"</span>)；\n        light.<span class=\"hljs-keyword\">on</span>()；\n        television.<span class=\"hljs-keyword\">on</span>();\n        aircondition.<span class=\"hljs-keyword\">on</span>()；\n    }\n\n    <span class=\"hljs-comment\">//起床后一键开电器</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> off{\n        <span class=\"hljs-comment\">//睡觉时一键关电器</span>\n        System.<span class=\"hljs-keyword\">out</span>.prinln(<span class=\"hljs-string\">\"睡觉了\"</span>)；\n        light.off()；\n        television.off();\n        aircondition.off()；\n    }\n}</code></pre>\n<ol start=\"3\">\n<li>使用情况</li>\n</ol>\n<pre><code class=\"hljs java\">public <span class=\"hljs-keyword\">class</span> Facade Pattern{\n    public static void main(String<span class=\"hljs-literal\">[]</span> args){\n        <span class=\"hljs-comment\">//实例化电器类</span>\n        SubSystemA_Light light = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">SubSystemA_Light()</span>;\n        SubSystemB_Television television = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">SubSystemB_Television()</span>;\n        SubSystemC_Aircondition aircondition = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">SubSystemC_Aircondition()</span>;\n\n        <span class=\"hljs-comment\">//传参</span>\n        Facade facade = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Facade(<span class=\"hljs-params\">light</span>,<span class=\"hljs-params\">television</span>,<span class=\"hljs-params\">aircondition</span>)</span>;\n\n        <span class=\"hljs-comment\">//客户端直接与外观对象进行交互</span>\n        facade.on<span class=\"hljs-literal\">()</span>;\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.prinln(<span class=\"hljs-string\">\"可以看电视了\"</span>)；\n        facade.off<span class=\"hljs-literal\">()</span>;\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.prinln(<span class=\"hljs-string\">\"可以睡觉了\"</span>)；\n    }\n}</code></pre>\n<h2 id=\"解决的问题\">解决的问题</h2>\n<p>外观模式完全符合 迪米特原则，它实现了使用者和内部系统的松耦合，内部系统为复杂的一系列操作提供一个简单的调用入口，使用者无需关注这一系列操作本身的复杂关系，只需要知道通过这个封装好的接口就能完成对应的交互。</p>\n<p>对于使用者（client）而言，使用者无需再关注系统的内部逻辑，能够专注于自己的业务代码。</p>\n<p>对应内部系统而言，无论内部一系列操作如果改变，只要提供对外的接口不不变，就不会影响到其客户使用。</p>\n<h2 id=\"使用场景\">使用场景</h2>\n<ol>\n<li>众多第三方库的对外 API 实际上都应用了外观模式来封装内部逻辑；</li>\n<li>日常开发中，遇到内部逻辑复杂，外部系统能需要组合一系列操作才能完成某一功能的时候，就可以使用外观模式进行封装；</li>\n</ol>\n<h3 id=\"在项目中的运用\">在项目中的运用</h3>\n<ol>\n<li>urs 登录注册组件的设计，该组件封装了对 urs 提供的组件的调用，当我们需要 urs 各类登录、注册组件的时候，只需要传入对应的参数即可；</li>\n</ol>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Huanqiang/imgBed/img/20200728150226.png\" alt=\"URS组件设计模式\"></p>\n<p>可以看出 URS 组件就是我们采用了外观模式封装的，他隔离了 URS 第三方提供的众多组件，后续组件只要使用该组件就可以了。</p>\n<p>但是有所缺陷的是，封装的不够彻底，没有将 URS 第三方组件的使用封装在该组件内部，而是由后续组件在调用传入；</p>\n<h2 id=\"与其他设计模式的关系\">与其他设计模式的关系</h2>\n<ul>\n<li><a href=\"https://refactoringguru.cn/design-patterns/facade\">外观模式</a>为现有对象定义了一个新接口， <a href=\"https://refactoringguru.cn/design-patterns/adapter\">适配器模式</a>则会试图运用已有的接口。 <em>适配器</em>通常只封装一个对象， <em>外观</em>通常会作用于整个对象子系统上。</li>\n<li>当只需对客户端代码隐藏子系统创建对象的方式时， 你可以使用<a href=\"https://refactoringguru.cn/design-patterns/abstract-factory\">抽象工厂模式</a>来代替<a href=\"https://refactoringguru.cn/design-patterns/facade\">外观</a>。</li>\n<li><a href=\"https://refactoringguru.cn/design-patterns/flyweight\">享元模式</a>展示了如何生成大量的小型对象， <a href=\"https://refactoringguru.cn/design-patterns/facade\">外观</a>则展示了如何用一个对象来代表整个子系统。</li>\n<li><a href=\"https://refactoringguru.cn/design-patterns/facade\">外观</a>和<a href=\"https://refactoringguru.cn/design-patterns/mediator\">中介者模式</a>的职责类似： 它们都尝试在大量紧密耦合的类中组织起合作。<ul>\n<li><em>外观</em>为子系统中的所有对象定义了一个简单接口， 但是它不提供任何新功能。 子系统本身不会意识到外观的存在。 子系统中的对象可以直接进行交流。</li>\n<li><em>中介者</em>将系统中组件的沟通行为中心化。 各组件只知道中介者对象， 无法直接相互交流。</li>\n</ul>\n</li>\n<li><a href=\"https://refactoringguru.cn/design-patterns/facade\">外观</a>类通常可以转换为<a href=\"https://refactoringguru.cn/design-patterns/singleton\">单例模式</a>类， 因为在大部分情况下一个外观对象就足够了。</li>\n<li><a href=\"https://refactoringguru.cn/design-patterns/facade\">外观</a>与<a href=\"https://refactoringguru.cn/design-patterns/proxy\">代理模式</a>的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。 <em>代理</em>与其服务对象遵循同一接口， 使得自己和服务对象可以互换， 在这一点上它与<em>外观</em>不同。</li>\n</ul>\n"}