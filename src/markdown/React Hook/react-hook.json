{"content":"<h1 id=\"react-hook\">React Hook</h1>\n<p>Hook 是 React 16.8 的新增特性，可以让开发者不使用 <code>class</code> 的情况下使用 <code>state</code> 及其他特性。</p>\n<h2 id=\"函数式组件\">函数式组件</h2>\n<p>函数式组件就是一个纯函数，它属于无状态组件（<code>Stateless Components</code>），返回了<code>DOM</code>或是其他组件，在函数组件中，你无法使用 State，也无法使用组件的生命周期方法，这就决定了函数组件都是展示性组件（<code>Presentational Components</code>），接收<code>Props</code>，渲染<code>DOM</code>，而不用关注其他逻辑。</p>\n<p>我们知道只要父组件进行了重渲染，函数式组件也要进行重渲染，而当函数式组件进行重渲染的时候，其实相当于重新执行了一次该函数，使得这个函数中的每一个变量都与之前的不一样了（除了表现形式），我们举个例子：</p>\n<blockquote>\n<p>例子来源 <a href=\"https://overreacted.io/how-are-function-components-different-from-classes/\">How Are Function Components Different from Classes?</a></p>\n</blockquote>\n<pre><code class=\"hljs react\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">ProfilePage</span>(<span class=\"hljs-params\">props</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> showMessage = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    alert(<span class=\"hljs-string\">'Followed '</span> + props.user);\n  };\n\n  <span class=\"hljs-keyword\">const</span> handleClick = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    setTimeout(showMessage, <span class=\"hljs-number\">3000</span>);\n  };\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{handleClick}</span>&gt;</span>Follow<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n  );\n}</code></pre>\n<p>在这个例子中，我们假设当前时刻 <code>props.user</code> 的值为 <code>”AAA“</code>，然后按下 <code>Follow</code> 按钮，再去更新 <code>props.user</code> 的值为 <code>”BBB“</code>，这样就会引起 <code>ProfilePage</code> 组件进行重渲染，然后过了 3 秒，弹窗出现，我们会发现弹框显示的信息仍是 <code>”AAA“</code>。</p>\n<p>这是因为 <strong>react 函数式组件始终会捕获、记录和使用当前渲染的 props、state</strong>。即在 <code>props.user</code> 的值更新之后，<code>ProfilePage</code> 组件进行了重渲染，也生成了新的 <code>handleClick</code> 和 <code>showMessage</code> 这两个函数，但是因为闭包的性质，所以之前那个 <code>props.user</code> 的值为 <code>”AAA“</code> 的 <code>showMessage</code> 函数仍然存在，且直到重渲染前的<code>handleClick</code>中的<code>setTimeout</code>执行完毕才会被销毁。所以说不仅重渲染前后的 <code>handleClick</code> 和 <code>showMessage</code> 这两个函数发生了变化，而且函数中对应的所捕获的值也是不一样，分别是更新前后的值。</p>\n<h2 id=\"出现的目的\">出现的目的</h2>\n<h3 id=\"1-用于代替-render-prop-和-高阶组件（hoc）。\">1. 用于代替 <code>render prop</code> 和 高阶组件（<code>HoC</code>）。</h3>\n<p>在 v16.8 之前，我们经常采用 <code>render prop</code> 和 高阶组件（<code>HoC</code>）来重构组件，这两种方法都能够很好的帮组我们复用组件和提取公共逻辑，但是它们会让项目/组件结构变得更加复杂，比如下面这个例子，该例子设置了一个最小屏幕宽度，当浏览器宽度大于设定值时，显示需要的组件，小于设定值时，不显示。</p>\n<pre><code class=\"hljs react\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>\n\n<span class=\"hljs-comment\">// 处理并获取当前屏幕宽度</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> WindowWidth <span class=\"hljs-keyword\">extends</span> React.Component {\n  <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">super</span>()\n    <span class=\"hljs-keyword\">this</span>.state = { width: <span class=\"hljs-built_in\">document</span>.documentElement.clientWidth }\n  }\n\n  componentDidMount() {\n    <span class=\"hljs-built_in\">window</span>.addEventListener(<span class=\"hljs-string\">'resize'</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">{ target }</span>) =&gt;</span> <span class=\"hljs-keyword\">this</span>.setState({ width: <span class=\"hljs-built_in\">document</span>.documentElement.clientWidth }))\n  }\n\n  componentWillUnmount() {\n    <span class=\"hljs-built_in\">window</span>.removeEventListener(<span class=\"hljs-string\">'resize'</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">{ target }</span>) =&gt;</span> <span class=\"hljs-keyword\">this</span>.setState({ width: <span class=\"hljs-built_in\">document</span>.documentElement.clientWidth }))\n  }\n\n  render() {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.props.children(<span class=\"hljs-keyword\">this</span>.state.width)\n  }\n}\n\n<span class=\"hljs-comment\">// 一个设置可显示组件的最小宽度的组件</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> MinWidth = <span class=\"hljs-function\">(<span class=\"hljs-params\">{ children }</span>) =&gt;</span> children(<span class=\"hljs-number\">600</span>)\n\n<span class=\"hljs-comment\">// 显示组件的组件</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> Content = <span class=\"hljs-function\">(<span class=\"hljs-params\">{ width, minWidth, children }</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> width &gt; minWidth ? children : <span class=\"hljs-literal\">null</span>\n}</code></pre>\n<p>使用如下:</p>\n<pre><code class=\"hljs react\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">WindowWidth</span>&gt;</span>\n  {width =&gt; (\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MinWidth</span>&gt;</span>\n      {minWidth =&gt; (\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Content</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">{width}</span> <span class=\"hljs-attr\">minWidth</span>=<span class=\"hljs-string\">{minWidth}</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>min-width requirement met!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Content</span>&gt;</span>\n      )}\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">MinWidth</span>&gt;</span>\n  )}\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">WindowWidth</span>&gt;</span></code></pre>\n<p>可以看出，我们使用了 <code>render prop</code> 来进行合理的组件化和复用，最外层的组件 <code>WindowWidth</code> 用于实时获取当前屏幕宽度，中间的组件 <code>MinWidth</code> 用于设置可显示组件的最小宽度，最内层的组件 <code>Content</code> 用于显示内容，要是加上 <code>Content</code> 的显示内容组件，光这里就需要四层组合了，这样就显得异常复杂，且难以理解。</p>\n<p>所以为了简化这种组件化的复杂程度，<code>React</code> 的设计者们推出了 <code>Hook</code>，让我们看一下如果使用 <code>Hook</code> 将会是什么效果。</p>\n<pre><code class=\"hljs react\"><span class=\"hljs-keyword\">import</span> React, { useState, useEffect } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>\n\n<span class=\"hljs-keyword\">const</span> useWidth = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  <span class=\"hljs-keyword\">const</span> [width, setWidth] = useState(<span class=\"hljs-built_in\">window</span>.innerWidth)\n  useEffect(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    <span class=\"hljs-built_in\">window</span>.addEventListener(<span class=\"hljs-string\">'resize'</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">{ target }</span>) =&gt;</span> setWidth(<span class=\"hljs-built_in\">document</span>.documentElement.clientWidth))\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n      <span class=\"hljs-built_in\">window</span>.removeEventListener(<span class=\"hljs-string\">'resize'</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">{ target }</span>) =&gt;</span> setWidth(<span class=\"hljs-built_in\">document</span>.documentElement.clientWidth))\n    }\n  }, [width])\n  <span class=\"hljs-keyword\">return</span> [width]\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> ContentHook = <span class=\"hljs-function\">(<span class=\"hljs-params\">{ minWidth, children }</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">const</span> [width] = useWidth()\n  <span class=\"hljs-keyword\">return</span> width &gt; minWidth ? children : <span class=\"hljs-literal\">null</span>\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> MinWidthHook = <span class=\"hljs-function\">(<span class=\"hljs-params\">{ children }</span>) =&gt;</span> children(<span class=\"hljs-number\">600</span>)</code></pre>\n<p>使用方式：</p>\n<pre><code class=\"hljs react\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MinWidthHook</span>&gt;</span>\n  {minWidth =&gt; (\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ContentHook</span> <span class=\"hljs-attr\">minWidth</span>=<span class=\"hljs-string\">{minWidth}</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>min-width requirement met!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ContentHook</span>&gt;</span>\n  )}\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">MinWidthHook</span>&gt;</span></code></pre>\n<p>在我们将外层用于实时获取当前屏幕宽度的组件 <code>WindowWidth</code> 改写成 <code>Hook</code> 之后，组件组合的层数直接少了一层，结果更加清晰，而且这个逻辑性的功能也被隐藏在了组件内部，无需开发者在外面使用。</p>\n<p>在之前的版本中，函数式组件没有 <code>state</code>，所以为了构建更合理的组件，开发者们不得不借助 <code>class</code> 组件操作 <code>state</code> 的能力，所以我们会使用高阶组件和 <code>render prop</code> 来进行组件的重构，但是这样就会提高组件的复杂程度。而 <code>Hook</code> 在保证了函数式组件纯净性的同时，还赋予了函数式组件赋予了操作 <code>state</code> 的能力，所以就能使得组件结构在更扁平化的同时还保持了同样的优雅`。</p>\n<blockquote>\n<p>可以看到自定义 <code>Hook</code> <code>useWidth</code> 其实就是一个函数。</p>\n</blockquote>\n<h3 id=\"2-使-react-更靠近声明式和函数式\">2. 使 React 更靠近声明式和函数式</h3>\n<h2 id=\"usestate-和-useeffect\"><code>useState</code> 和 <code>useEffect</code></h2>\n<p>让我们看看 <code>Hook</code> 中最基础的两个<code>API</code> <code>useState</code> 和 <code>useEffect</code> 的使用方法。</p>\n<h3 id=\"usestate\"><code>useState</code></h3>\n<pre><code class=\"hljs react\"><span class=\"hljs-keyword\">import</span> React, { useState } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Example</span> (<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">const</span> [name, setName] = useState(<span class=\"hljs-string\">'AAA'</span>)\n    <span class=\"hljs-keyword\">return</span> (<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>{ name }<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> setName('BBB')}&gt;change name<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>)\n}</code></pre>\n<p>这就是一个最标准的的 <code>useState</code> 的使用，<code>useState</code> 函数会返回一个数组，其中第一个元素是 <code>state</code>，第二个元素是改变当前 state 的方法，比如上面这个例子中的 <code>state</code> 就是 <code>name</code>，而 <code>setName</code> 就是用于改变 <code>name</code> 值的方法，相当于 <code>setState({name: value})</code>，当然 <code>setName</code> 方法是直接生成了一个新的值来替换了原来的值。同时该方法还接收一个初始值，用于在第一次渲染时候的给 <code>state</code> 赋值，而在此后，无论是内部 <code>state</code> 的变化还是 <code>prop</code> 的变化所引起的组件重渲染都不会再用到这个值了。下面这个例子进行了很好地说明。</p>\n<pre><code class=\"hljs react\"><span class=\"hljs-keyword\">import</span> React, { useState } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Example</span>(<span class=\"hljs-params\">{ firstName }</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> [lastName, setLastName] = useState(firstName)\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'lastName'</span>)\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n        {lastName} + {firstName}\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> setLastName('BBB')}&gt;change lastName<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  )\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ExampleWarp</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n  state = {\n    <span class=\"hljs-attr\">firstName</span>: <span class=\"hljs-string\">'ExampleWarp'</span>,\n    <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">0</span>\n  }\n\n  changeFirstName = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    <span class=\"hljs-keyword\">this</span>.setState(<span class=\"hljs-function\"><span class=\"hljs-params\">prevState</span> =&gt;</span> ({\n      <span class=\"hljs-attr\">count</span>: prevState.count++,\n      <span class=\"hljs-attr\">firstName</span>: prevState.firstName + prevState.count\n    }))\n  }\n\n  render() {\n    <span class=\"hljs-keyword\">const</span> { firstName } = <span class=\"hljs-keyword\">this</span>.state\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Example</span> <span class=\"hljs-attr\">firstName</span>=<span class=\"hljs-string\">{firstName}</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{this.changeFirstName}</span>&gt;</span>change firstName<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n    )\n  }\n}</code></pre>\n<p>值得注意的是，这个名为 <code>lastName</code> 的 <code>state</code>，在组件每次调用的时候都是一个常量，即每次重渲染的时候都是重新声明并赋值的，赋的就是当前调用时候的<code>state</code>的值，之所以在每次渲染的结果会变，是因为每次渲染所使用的都是不同的值 详见 <a href=\"https://overreacted.io/zh-hans/react-as-a-ui-runtime/\">https://overreacted.io/zh-hans/react-as-a-ui-runtime/</a></p>\n<pre><code class=\"hljs react\"><span class=\"hljs-comment\">// During first render</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Counter</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> count = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// Returned by useState()</span>\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">handleAlertClick</span>(<span class=\"hljs-params\"></span>) </span>{\n    setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n      alert(<span class=\"hljs-string\">'You clicked on: '</span> + count);\n    }, <span class=\"hljs-number\">3000</span>);\n  }\n  <span class=\"hljs-comment\">// ...</span>\n}\n\n<span class=\"hljs-comment\">// After a click, our function is called again</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Counter</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> count = <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// Returned by useState()</span>\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">handleAlertClick</span>(<span class=\"hljs-params\"></span>) </span>{\n    setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n      alert(<span class=\"hljs-string\">'You clicked on: '</span> + count);\n    }, <span class=\"hljs-number\">3000</span>);\n  }\n  <span class=\"hljs-comment\">// ...</span>\n}\n\n<span class=\"hljs-comment\">// After another click, our function is called again</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Counter</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> count = <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">// Returned by useState()</span>\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">handleAlertClick</span>(<span class=\"hljs-params\"></span>) </span>{\n    setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n      alert(<span class=\"hljs-string\">'You clicked on: '</span> + count);\n    }, <span class=\"hljs-number\">3000</span>);\n  }\n  <span class=\"hljs-comment\">// ...</span>\n}</code></pre>\n<h3 id=\"useeffect\"><code>useEffect</code></h3>\n<h4 id=\"基本使用\">基本使用</h4>\n<p><code>useEffect</code> 顾名思义就是用于处理副作用的。在 <code>React Hook</code> 中，我们可以把所有具有副作用的操作都放在 <code>useEffect</code> 中执行，比如操作<code>DOM</code>，网络请求等。</p>\n<pre><code class=\"hljs react\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Example</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">const</span> [name, setName] = useState(<span class=\"hljs-literal\">null</span>)\n  useEffect() {\n        fetch(<span class=\"hljs-string\">\"http://xxx\"</span>)\n      .then(<span class=\"hljs-function\"><span class=\"hljs-params\">response</span> =&gt;</span> response.json())\n      .then(<span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =&gt;</span> setName(data.name))\n  }\n  ...\n}</code></pre>\n<p>如果该异步操作需要在组件<code>unmount</code>时候被清除的，比如 <code>setTimeout</code>、<code>addEventListener</code> 等操作，我们需要在 <code>useEffect</code> 函数中手动返回清除操作函数。</p>\n<pre><code class=\"hljs react\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Example</span>(<span class=\"hljs-params\"></span>) </span>{\n    ...\n    useEffect() {\n        <span class=\"hljs-keyword\">const</span> timeid = setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span>=&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"test useEffect\"</span>), <span class=\"hljs-number\">1000</span>)\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> clearTimeout(timeid);\n    }\n    ...\n}</code></pre>\n<h4 id=\"什么时候调用-useeffect\">什么时候调用 <code>useEffect</code></h4>\n<p>在每次渲染函数的时候都会调用 <code>useEffect</code>，<code>useEffect</code> 和 <code>useState</code> 一样，在每次渲染的时候必须按次序地调用所有的 <code>useEffect</code> 和 <code>useState</code>。（具体原因见 <a href=\"https://zh-hans.reactjs.org/docs/hooks-effect.html#explanation-why-effects-run-on-each-update\">解释: 为什么每次更新的时候都要运行 Effect</a>）</p>\n<h4 id=\"什么时候执行-useeffert-中的内容\">什么时候执行 <code>useEffert</code> 中的内容</h4>\n<p>在每次调用 <code>useEffert</code> 的时候，事实上组件只会记录当前的 <code>effert</code> 函数，然后<strong>等到 UI 渲染完成</strong>（在界面上可见）后，<strong>再去调用清除函数</strong>（清理上一次的 <code>effert</code>），然后<strong>再执行本次的<code>effert</code>函数</strong>。</p>\n<h4 id=\"什么时候调用清除函数\">什么时候调用清除函数</h4>\n<ol>\n<li>组件被卸载的时候；</li>\n<li>当 effert 函数需要被再次执行的时候；</li>\n</ol>\n<h4 id=\"跳过-useeffect-的-effert-函数的执行\">跳过 <code>useEffect</code> 的 <code>effert</code> 函数的执行</h4>\n<p>我们已经知道在每次更新的时候调用 <code>useEffect</code>，而且每次更新的时候都必须要调用 <code>useEffect</code>。所以下面将 <code>useEffect</code> 放在条件语句中以跳过 <code>useEffect</code> 的方式必然是会出问题的：</p>\n<pre><code class=\"hljs react\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Example</span>(<span class=\"hljs-params\">props</span>) </span>{\n    ...\n    <span class=\"hljs-keyword\">if</span> (props.render) {\n        useEffect(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {})\n    }\n    ...\n}</code></pre>\n<p>其实 <code>useEffect</code> 还有第二个参数，就是用于控制重渲染/更新的时候是否调用 <code>useEffect</code> 函数内的内容（<strong>注意，<code>useEffect</code> 是必然被调用的，只是跳过了其内容部分的执行</strong>）。第二个参数允许我们传入一个数组，每一个元素都能控制 <code>useEffect</code> 是否需要执行。</p>\n<pre><code class=\"hljs react\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Example</span>(<span class=\"hljs-params\">props</span>) </span>{\n   <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>)\n    useEffect(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n          <span class=\"hljs-built_in\">document</span>.title = <span class=\"hljs-string\">`You clicked <span class=\"hljs-subst\">${count}</span> times`</span>;\n    }, [count]); <span class=\"hljs-comment\">// 仅在 count 更改时更新</span>\n    ...\n}</code></pre>\n<p>在这段代码中，只有当 <code>count</code> 的值改变了的时候，才会执行 <code>useEffect</code> 内部的代码。这段代码如果用 <code>class</code> 组件来写的话，相当于：</p>\n<pre><code class=\"hljs react\">class Example extends React.Component {\n  constructor(props) {\n    super(props);\n    this.<span class=\"hljs-keyword\">state</span> = {\n      count: <span class=\"hljs-number\">0</span>\n    };\n  }\n\n  componentDidMount() {\n    document.title = `You clicked ${this.<span class=\"hljs-keyword\">state</span>.count} times`;\n  }\n\n  componentDidUpdate() {\n    if (prevState.count !== this.<span class=\"hljs-keyword\">state</span>.count) {\n        document.title = `You clicked ${this.<span class=\"hljs-keyword\">state</span>.count} times`;\n       }\n  }\n\n  render() {\n    ...\n  }\n}</code></pre>\n<p>又比如，我们希望某一操作仅在 <code>componentDidMount</code> 的时候执行一次，之后不再执行，我们只需要在第二个参数位置传入一个空数组即可：</p>\n<pre><code class=\"hljs react\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Example</span>(<span class=\"hljs-params\">props</span>) </span>{\n   <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>)\n    useEffect(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n          <span class=\"hljs-built_in\">document</span>.title = <span class=\"hljs-string\">`You clicked <span class=\"hljs-subst\">${count}</span> times`</span>;\n    }, []); <span class=\"hljs-comment\">// 仅在 count 更改时更新</span>\n    ...\n}</code></pre>\n<p>它相当于：</p>\n<pre><code class=\"hljs react\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Example</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n  constructor(props) {\n    <span class=\"hljs-keyword\">super</span>(props);\n    <span class=\"hljs-keyword\">this</span>.state = {\n      count: <span class=\"hljs-number\">0</span>\n    };\n  }\n\n  componentDidMount() {\n    document.title = `<span class=\"hljs-type\">You</span> clicked ${<span class=\"hljs-keyword\">this</span>.state.count} times`;\n  }\n\n  render() {\n    ...\n  }\n}</code></pre>\n<h2 id=\"hook-原理\">hook 原理</h2>\n<p>参见：<a href=\"https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e\">React hooks: not magic, just arrays</a>，</p>\n<p><code>useState</code> 函数创建的 <code>{state, setState}</code> 这两个返回值，分别存在于两个数组中，如下面的例子，当一个函数组件中存在多个 <code>useState</code> 的时候，那么这些 <code>state</code> 和 <code>setState</code>，也是依次存储的。</p>\n<pre><code class=\"hljs react\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">RenderFunctionComponent</span>(<span class=\"hljs-params\">props</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> [firstName, setFirstName] = useState(<span class=\"hljs-string\">\"Rudi\"</span>);\n  <span class=\"hljs-keyword\">const</span> [lastName, setLastName] = useState(<span class=\"hljs-string\">\"Yardley\"</span>);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> setFirstName(\"Fred\")}&gt;Fred<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Button</span>&gt;</span></span>\n  );\n}</code></pre>\n<p>其 <code>state</code> 对应的存储如下图：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Huanqiang/imgBed/blog/WeChat66e4e203459883bcd6d586466f06ce9f.png\" alt=\"state 的存储方式\"></p>\n<p>正如我们所看到了，<code>React</code> 将一个函数式组件里的 <code>useState</code> 结果依次存在，所以我们不能随意的在某一个重渲染中省略任意一个 <code>useState</code> 的执行，也就是说像如下写法都是会出错的。</p>\n<pre><code class=\"hljs react\"><span class=\"hljs-keyword\">let</span> firstRender = <span class=\"hljs-literal\">true</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">RenderFunctionComponent</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">let</span> initName;\n\n  <span class=\"hljs-keyword\">if</span>(firstRender){\n    [initName] = useState(<span class=\"hljs-string\">\"Rudi\"</span>);\n    firstRender = <span class=\"hljs-literal\">false</span>;\n  }\n  <span class=\"hljs-keyword\">const</span> [firstName, setFirstName] = useState(initName);\n  <span class=\"hljs-keyword\">const</span> [lastName, setLastName] = useState(<span class=\"hljs-string\">\"Yardley\"</span>);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> setFirstName(\"Fred\")}&gt;Fred<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Button</span>&gt;</span></span>\n  );\n}</code></pre>\n<p>虽然你把这个<code>firstName</code>对应的 <code>useState</code> 给过滤了，但是事实上 <code>react</code> 并不知道，在它的算法中，它仅仅是按照顺序去对应每次组件重渲染时候的 <code>useState</code> 的返回值。所以如果 <code>firstRender === false</code> ，那么该次渲染就会出错，<code>React</code> 会把本应属于 <code>initName</code> 的值赋给 <code>firstName</code>，把本应属于 <code>firstName</code> 的值赋给 <code>lastName</code>。</p>\n<p>第一次渲染，即当 <code>firstRender === ture</code> 的时候，其对应效果图如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Huanqiang/imgBed/blog/1C4IA_Y7v6eoptZTBspRszQ.png\" alt=\"1C4IA_Y7v6eoptZTBspRszQ\"></p>\n<p>第二次渲染，即当 <code>firstRender === false</code> 的时候，其对应效果图如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Huanqiang/imgBed/blog/1aK7jIm6oOeHJqgWnNXt8Ig.png\" alt=\"1aK7jIm6oOeHJqgWnNXt8Ig\"></p>\n<blockquote>\n<p>图来自 <a href=\"https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e\">React hooks: not magic, just arrays</a></p>\n</blockquote>\n<h2 id=\"其他-api\">其他 API</h2>\n<h3 id=\"usecallback\">useCallback</h3>\n<p>useCallback 实际上就是给函数添加了一层依赖检查，使之在确实改变了之后才进行更新。看例子：</p>\n<pre><code class=\"hljs react\"><span class=\"hljs-keyword\">import</span> React, {useState, uesCallback} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Example</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">const</span> [query, setQuery] = useState(<span class=\"hljs-string\">'react'</span>)\n    <span class=\"hljs-keyword\">const</span> getFetchUrl = <span class=\"hljs-function\">(<span class=\"hljs-params\">query</span>) =&gt;</span> {\n        fetch(<span class=\"hljs-string\">'http://xxx'</span>, query)\n    }\n\n    useEffect(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span>=&gt;</span> {\n        getFetchUrl(query)\n    }, [getFetchUrl, query])\n  ...\n}</code></pre>\n<p>在这个例子中，我们将请求函数从 useEffect 中提取出来，我们希望的是，只有当 query 改变之后，useEffect 中的<code>getFetchUrl</code> 函数才会重新执行。而事实上，这个 <code>getFetchUrl</code> 函数在每次函数重渲染的时候都会执行，即这个 useEffect 里的内容都会被调用。你可能会疑问为什么会有这样的操作：<em>getFetchUrl 函数不是每次都一样嘛，如果 query 没有变的话，那么 useEffect 的依赖不是没有发生改变，那么为什么 useEffect 里的内容每次重渲染都会被调用？</em></p>\n<p>之所以会有这样的问题，就是因为在事实上每次组件重渲染的时候，getFetchUrl 都发生了变化。在每次组件重渲染的时候，函数都重新执行了一遍，这也就意味着 getFetchUrl 这个函数被重新声明赋值了，其内存地址已经发生了变化，只不过在重渲染前后，我们给这两个不同的内存地址设置了相同的内容而已。</p>\n<p>所以想要达到正确的目的，我们可以把 fetch 请求放到 useEffect 中就可以了，这样就保证了每次只依赖于 query 这一个变量。</p>\n<pre><code class=\"hljs react\"><span class=\"hljs-keyword\">import</span> React, {useState, uesCallback} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Example</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">const</span> [query, setQuery] = useState(<span class=\"hljs-string\">'react'</span>)\n    useEffect(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span>=&gt;</span> {\n        fetch(<span class=\"hljs-string\">'http://xxx'</span>, query)\n    }, [query])\n  ...\n}</code></pre>\n<p>但是，如果说一定要将请求提取出来，那么我们可以借助 useCallback 来达到目的。useCallback 为我们的函数加了一层 query 的检查，只要 query 不变，那么 getFetchUrl 这个函数就不变，所以 useEffect 里的内容也不会被执行（注意，useEffect 本身还是调用了的）。</p>\n<pre><code class=\"hljs react\"><span class=\"hljs-keyword\">import</span> React, {useState, uesCallback} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Example</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">const</span> [query, setQuery] = useState(<span class=\"hljs-string\">'react'</span>)\n    <span class=\"hljs-keyword\">const</span> getFetchUrl = useCallback(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n        fetch(<span class=\"hljs-string\">'http://xxx'</span>, query)\n    }, [query])\n\n    useEffect(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span>=&gt;</span> {\n        getFetchUrl()\n    }, [getFetchUrl])\n  ...\n}</code></pre>\n<h3 id=\"useref\">useRef</h3>\n<p>在典型的 <code>React</code> 应用中，我们不能直接操作<code>DOM</code>元素，同样的，父组件也不能直接操作子组件，只能通过<code>props</code>来重新渲染它。如果遇到非要操作 DOM 元素或是子组件的方法的时候，你就需要 <code>ref</code> 了，它指向了我们所需要操作的 DOM 元素或是组件的实例。</p>\n<blockquote>\n<p><strong>不能在函数组件上使用 ref 属性，因为函数组件没有实例</strong></p>\n</blockquote>\n<p>而在 Hook 中，useRef 除了能指向 DOM 元素或组件 的实例之外，还能指向任意一个数据。如下实例：</p>\n<pre><code class=\"hljs react\"><span class=\"hljs-keyword\">import</span> React, {uesRef} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Example</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> ref = useRef(<span class=\"hljs-literal\">null</span>)\n\n  <span class=\"hljs-keyword\">const</span> changeValue = <span class=\"hljs-function\">(<span class=\"hljs-params\">e</span>) =&gt;</span> {\n        ref.current = e.target.value\n  }\n  ...\n}</code></pre>\n<p>通常你并不需要这样的操作，但是<strong>如果你需要获取不属于当前组件的 <code>props</code> 或 <code>state</code> 的时候</strong>，那么你就需要 <code>useRef</code> 了。</p>\n<p>实际上，<code>const ref = useRef(null)</code> 所返回的只是一个“普通”的 JS 对象，只不过它的值不会随着你的函数式组件重新渲染而变化，即每次渲染的时候 <code>useRef</code> 都会返回同一个值。同样的，<code>ref.current</code> 的改变也不会引起函数的重新渲染，就好像这是一个存在于函数之外的全局变量一样。</p>\n<blockquote>\n<p>事实上，<code>ref.current</code> 确实存在于该函数之外。如同 <code>const { state, setState } = useState(initState);</code> 一样。</p>\n</blockquote>\n<h2 id=\"必看资料\">必看资料</h2>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/50597236\">一篇看懂 React Hooks</a></li>\n<li><a href=\"https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/\">useEffect 完整指南</a></li>\n<li><a href=\"https://overreacted.io/zh-hans/making-setinterval-declarative-with-react-hooks/\">使用 React Hooks 声明 setInterval</a> ：精妙绝伦。</li>\n<li><a href=\"https://overreacted.io/how-are-function-components-different-from-classes/\">How Are Function Components Different from Classes?</a>，译文：<a href=\"https://zhuanlan.zhihu.com/p/62767474\">React 函数组件和类组件的差异</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/66166173\">useMemo 与 useCallback 使用指南</a></li>\n</ul>\n"}