{"content":"<h1 id=\"小程序底层框架\">小程序底层框架</h1>\n<blockquote>\n<p>整理自<a href=\"https://developers.weixin.qq.com/ebook?action=get_post_info&amp;docid=0008aeea9a8978ab0086a685851c0a\">《小程序官方文档》</a></p>\n</blockquote>\n<h2 id=\"技术选型\">技术选型</h2>\n<p>小程序选择的是类似 <code>JSSDK</code> 的 Hybird 技术，界面主要是有成熟的 web 技术渲染，然后辅之以大量的接口来提供丰富的客户端原生能力。同时，每个小程序页面都是用不同的WebView去渲染，这样可以提供更好的交互体验，更贴近原生体验，也避免了单个WebView的任务过于繁重。</p>\n<p>不选择纯原生的原因是：如果选择原生，那么小程序代码必须要与微信代码一起发布，这样会影响开发的节奏。因此，小程序需要像Web 技术那样，有一份随时可更新的资源包放在云端，通过下载到本地，动态执行后即可渲染出界面。</p>\n<p>不选择纯Web的原因是：用纯 Web 技术来渲染小程序，在一些有复杂交互的页面上可能会面临一些性能问题，这是因为在 Web 技术中，UI渲染跟 JavaScript 的脚本执行都在一个单线程中执行，这就容易导致一些逻辑任务抢占UI渲染的资源。</p>\n<p>不选择React Native 的原因是：虽然说 RN 是结合了 React 框架的代码组成方式，但是我们完全可以剥离React 框架这套写法，定义出更符合小程序特点的代码组成方式。不过，最终并没有选择这种类 RN 技术，原因有三：</p>\n<ol>\n<li>RN 所支持的样式是 CSS 的子集，会满足不了 Web 开发者日渐增长的需求，而对 RN 的改造具有不小的成本和风险。</li>\n<li>RN 现有能力下还存在的一些不稳定问题，比如性能、Bug等。RN 是把渲染工作全都交由客户端原生渲染，实际上一些简单的界面元素使用 Web 技术渲染完全能胜任，并且非常稳定。</li>\n<li>RN 存在一些不可预期的因素，比如近期就出现了许可协议问题。</li>\n</ol>\n<h2 id=\"双线程模型\">双线程模型</h2>\n<p>小程序的运行环境分成了两个线程，分别是执行JS业务逻辑的单独线程（即逻辑层）和执行渲染界面任务的 WebView 线程（即渲染层）。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Huanqiang/imgBed/blog/xxxx.png\" alt=\"xxxx\"></p>\n<h3 id=\"使用双线程模型的原因\">使用双线程模型的原因</h3>\n<p>基于Web 技术来渲染小程序是存在一些不可控因素和安全风险的。这是因为Web技术是非常开放灵活的，我们可以利用 <strong>JavaScript 脚本随意地跳转网页</strong>或者<strong>改变界面上的任意内容</strong>，比如跳转页面、操作DOM、动态执行脚本的开放性接口。</p>\n<p>但是因为 <code>JavaScript</code> 的灵活性以及浏览器接口的丰富性，很容易遗漏一些危险的接口，而且就算找到所有危险的接口，也许在下一次浏览器内核更新而新增了一个可能会在这套体系下产生漏洞的接口，所以还是无法完全避免这些安全风险。</p>\n<p>因此，要彻底解决这个问题，我们必须<strong>提供一个沙箱环境</strong>来运行开发者的 <code>JavaScript</code> 代码。这个沙箱环境不能有任何浏览器相关接口，只提供纯 <code>JavaScript</code> 的解释执行环境。那么像 <code>HTML5</code> 中的<code>ServiceWorker</code>、<code>WebWorker</code> 特性就符合这样的条件，这两者都是启用另一线程来执行 <code>JavaScript</code>。但是考虑到小程序是一个多 <code>WebView</code> 的架构，每一个小程序页面都是不同的 <code>WebView</code> 渲染后显示的，在这个架构下我们不好去用某个<code>WebView</code>中的<code>ServiceWorker</code>去管理所有的小程序页面。</p>\n<p>所以就可以创建一个单独的线程，然后借助客户端原有 <code>JavaScript</code> 的解释引擎来执行 <code>js</code> 代码。（在<code>iOS</code>下是用内置的 <code>JavaScriptCore</code>框架，在安卓则是用腾讯x5内核提供的<code>JsCore</code>环境），然后把界面渲染相关的任务全都在 <code>WebView</code> 线程里执行，通过逻辑层代码去控制渲染哪些界面，那么这一层当然就是所谓的渲染层。这就是小程序双线程模型的由来。</p>\n<h3 id=\"page-生命周期\">Page 生命周期</h3>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Huanqiang/imgBed/blog/page-lifecycle.2e646c86.png\" alt=\"page-lifecycle.2e646c86\"></p>\n<blockquote>\n<p>上图右侧的即生命周期函数的执行顺序</p>\n</blockquote>\n<h2 id=\"组件系统\">组件系统</h2>\n<p>小程序之所以创建自己创建一个组件系统，自定义标签的原因是 小程序的视图是在 WebView 里面渲染的，如果使用没有自己的一套组件系统，那么其构建页面的就只能使用 HTML，而如果开发者直接使用 HTML 的话，那么开发者就拥有了随意地跳转网页（利用 A 标签）和动态执行 JS 的能力。而这样，前面章节所介绍的为解决管控与安全而建立的双线程模型就成为摆设了。</p>\n<p>除此之外，直接使用 HTML 还具有以下不足：</p>\n<ul>\n<li>标签众多，增加理解成本；</li>\n<li>接口底层，不利于快速开发；</li>\n<li>能力有限，会限制小程序的表现形式。</li>\n</ul>\n<h3 id=\"exparser框架\">Exparser框架</h3>\n<p><code>Exparser</code> 是微信小程序的组件组织框架，内置在小程序基础库中，为小程序的各种组件提供基础的支持。小程序内的所有组件，包括内置组件和自定义组件，都由<code>Exparser</code>组织管理。</p>\n<p><code>Exparser</code>的组件模型与<code>WebComponents</code>标准中的<code>ShadowDOM</code>高度相似。<code>Exparser</code>会维护整个页面的节点树相关信息，包括节点的属性、事件绑定等，相当于一个简化版的<code>Shadow DOM</code>实现。<code>Exparser</code>的主要特点包括以下几点：</p>\n<ol>\n<li>基于<code>Shadow DOM</code>模型：模型上与<code>WebComponents</code>的<code>ShadowDOM</code>高度相似，但不依赖浏览器的原生支持，也没有其他依赖库；实现时，还针对性地增加了其他API以支持小程序组件编程。</li>\n<li>可在纯JS环境中运行：这意味着逻辑层也具有一定的组件树组织能力。</li>\n<li>高效轻量：性能表现好，在组件实例极多的环境下表现尤其优异，同时代码尺寸也较小。</li>\n</ol>\n<p>小程序中，所有节点树相关的操作都依赖于 <code>Exparser</code>，包括 <code>WXML</code> 到页面最终节点树的构建、 <code>createSelectorQuery</code>调用和自定义组件特性等。</p>\n<h2 id=\"小程序错误捕获\">小程序错误捕获</h2>\n<p>这两个方案都无法捕捉代码的语法错误，但是一般在开发阶段，工具就已经能够显示出脚本的语法错误，因此这类异常完全是可以在开发阶段消除，运行阶段并不会有此类异常发生。对比<code>window.onerror</code>的方案，<code>try-catch</code>的方案有个缺点：没法捕捉到全局的错误事件，也即是只有<code>try-catch</code>的块里边代码运行出错才会被捕捉到。逻辑层不存在<code>window</code>对象，因此逻辑层<code>AppService</code>侧无法通过<code>window.onerror</code>来捕捉异常。</p>\n<p>所以小程序基础库在<code>WebView</code>侧使用<code>window.onerror</code>方案进行捕捉异常，在逻辑层<code>AppService</code>侧通过把<code>App</code>实例和<code>Page</code>实例的各个生命周期等方法包裹在<code>try-catch</code>里进行捕捉异常。同时在<code>App</code>构造器里提供了<code>onError</code>的回调，当业务代码运行产生异常时，这个回调被触发，同时能够拿到异常的具体信息，开发者自己根据业务情况处理对应的容错逻辑。</p>\n"}